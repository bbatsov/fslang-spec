
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://fsharp.github.io/fslang-spec/patterns/">
      
      
        <link rel="prev" href="../expressions/">
      
      
        <link rel="next" href="../type-definitions/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.11">
    
    
      
        <title>Patterns - F# Language Specification</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.4af4bdda.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#patterns" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="F# Language Specification" class="md-header__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            F# Language Specification
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Patterns
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="F# Language Specification" class="md-nav__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    F# Language Specification
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../front-matter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    F# Language Specification
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../introduction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Program Structure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-analysis/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lexical Analysis
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic-grammar-elements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic Grammar Elements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../types-and-type-constraints/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Types and Type Constraints
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../expressions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Expressions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Patterns
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Patterns
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#simple-constant-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Simple Constant Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#named-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Named Patterns
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Named Patterns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#union-case-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Union Case Patterns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#literal-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Literal Patterns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#active-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Active Patterns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#as-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      “As” Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#wildcard-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Wildcard Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#disjunctive-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Disjunctive Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conjunctive-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Conjunctive Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      List Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#type-annotated-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Type-annotated Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dynamic-type-test-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Dynamic Type-test Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#record-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Record Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#array-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Array Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#null-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Null Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#guarded-pattern-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Guarded Pattern Rules
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../type-definitions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Type Definitions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../units-of-measure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Units of Measure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespaces-and-modules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Namespaces and Modules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespace-and-module-signatures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Namespace and Module Signatures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure-and-execution/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Program Structure and Execution
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../custom-attributes-and-reflection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Custom Attributes and Reflection
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../inference-procedures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Inference Procedures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-filtering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lexical Filtering
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../provided-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Provided Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../special-attributes-and-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Special Attributes and Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../the-f-library-fsharpcoredll/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    The F# Library FSharp.Core.dll
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../features-for-ml-compatibility/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Features for ML Compatibility
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#simple-constant-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Simple Constant Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#named-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Named Patterns
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Named Patterns">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#union-case-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Union Case Patterns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#literal-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Literal Patterns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#active-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Active Patterns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#as-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      “As” Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#wildcard-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Wildcard Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#disjunctive-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Disjunctive Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conjunctive-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Conjunctive Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      List Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#type-annotated-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Type-annotated Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dynamic-type-test-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Dynamic Type-test Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#record-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Record Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#array-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Array Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#null-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Null Patterns
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#guarded-pattern-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Guarded Pattern Rules
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="patterns">Patterns</h1>
<p>Patterns are used to perform simultaneous case analysis and decomposition on values together with
the <code>match</code>, <code>try...with</code>, <code>function</code>, <code>fun</code>, and <code>let</code> expression and declaration constructs. Rules are
attempted in order from top to bottom and left to right. The syntactic forms of patterns are shown
in the subsequent table.</p>
<pre><code class="language-fsgrammar">rule :=
    pat pattern-guard~opt -&gt; expr       -- pattern, optional guard and action

pattern-guard := when expr

pat :=
    const                               -- constant pattern
    long-ident pat-param~opt pat~opt    -- named pattern
    _ -- wildcard pattern
    pat as ident                        -- &quot;as&quot; pattern
    pat '|' pat                         -- disjunctive pattern
    pat '&amp;' pat                         -- conjunctive pattern
    pat :: pat                          -- &quot;cons&quot; pattern
    pat : type                          -- pattern with type constraint
    pat , ... , pat                     -- tuple pattern
    struct (pat , ... , pat)            -- struct tuple pattern
    ( pat )                             -- parenthesized pattern
    list-pat                            -- list pattern
    array-pat                           -- array pattern
    record-pat                          -- record pattern
    :? atomic-type                      -- dynamic type test pattern
    :? atomic-type as ident             -- dynamic type test pattern
    null                                -- null-test pattern
    attributes pat                      -- pattern with attributes

list-pat :=
    [ ]
    [ pat ; ... ; pat ]

array-pat :=
    [| |]
    [| pat ; ... ; pat |]

record-pat :=
    { field-pat ; ... ; field-pat }

atomic-pat :=
    pat : one of
            const long-ident list-pat record-pat array-pat ( pat )
            :? atomic-type
            null _

field-pat := long-ident = pat

pat-param :=
    | const
    | long-ident
    | [ pat-param ; ... ; pat-param ]
    | ( pat-param , ..., pat-param )
    | long-ident pat-param
    | pat-param : type
    | &lt;@ expr @&gt;
    | &lt;@@ expr @@&gt;
    | null

pats := pat , ... , pat
field-pats := field-pat ; ... ; field-pat
rules := '|'~opt rule '|' ... '|' rule
</code></pre>
<p>Patterns are elaborated to expressions through a process called <em>pattern match compilation</em>. This
reduces pattern matching to <em>decision trees</em> which operate on an input value, called the <em>pattern input</em>.
The decision tree is composed of the following constructs:</p>
<ul>
<li>Conditionals on integers and other constants</li>
<li>Switches on union cases</li>
<li>Conditionals on runtime types</li>
<li>Null tests</li>
<li>Value definitions</li>
<li>An array of pattern-match targets referred to by index</li>
</ul>
<h2 id="simple-constant-patterns">Simple Constant Patterns</h2>
<p>The pattern <code>const</code> is a <em>constant pattern</em> which matches values equal to the given constant. For
example:</p>
<pre><code class="language-fsharp">let rotate3 x =
    match x with
    | 0 -&gt; &quot;two&quot;
    | 1 -&gt; &quot;zero&quot;
    | 2 -&gt; &quot;one&quot;
    | _ -&gt; failwith &quot;rotate3&quot;
</code></pre>
<p>In this example, the constant patterns are 0, 1, and 2. Any constant listed in <a href="../expressions/#simple-constant-expressions">§6.3.1</a> may be used as a
constant pattern except for integer literals that have the suffixes <code>Q</code>, <code>R</code>, <code>Z</code>, <code>I</code>, <code>N</code>, <code>G</code>.</p>
<p>Simple constant patterns have the corresponding simple type. Such patterns elaborate to a call to
the F# structural equality function <code>FSharp.Core.Operators.(=)</code> with the pattern input and the
constant as arguments. The match succeeds if this call returns <code>true</code>; otherwise, the match fails.</p>
<blockquote>
<p><strong>Note</strong>: The use of <code>FSharp.Core.Operators.(=)</code> means that CLI floating-point equality is
used to match floating-point values, and CLI ordinal string equality is used to match
strings.</p>
</blockquote>
<h2 id="named-patterns">Named Patterns</h2>
<p>Patterns in the following forms are <em>named patterns</em> :</p>
<pre><code class="language-fsgrammar">Long-ident
Long-ident pat
Long-ident pat-params pat
</code></pre>
<p>If <code>long-ident</code> is a single identifier that does not begin with an uppercase character, it is interpreted
as a <em>variable pattern</em>. During checking, the variable is assigned the same value and type as the
pattern input.</p>
<p>If <code>long-ident</code> is more than one-character long or begins with an uppercase character (that is, if
<code>System.Char.IsUpperInvariant</code> is <code>true</code> and <code>System.Char.IsLowerInvariant</code> is <code>false</code> on the first
character), it is resolved by using <em>Name Resolution in Patterns</em> (<a href="../inference-procedures/#name-resolution-in-patterns">§14.1.6</a>). This algorithm produces one
of the following:</p>
<ul>
<li>A union case</li>
<li>An exception label</li>
<li>An active pattern case name</li>
<li>A literal value</li>
</ul>
<p>Otherwise, <code>long-ident</code> must be a single uppercase identifier <code>ident</code>. In this case, <code>pat</code> is a variable
pattern. An F# implementation may optionally generate a warning if the identifier is uppercase. Such
a warning is recommended if the length of the identifier is greater than two.</p>
<p>After name resolution, the subsequent treatment of the named pattern is described in the following
sections.</p>
<h3 id="union-case-patterns">Union Case Patterns</h3>
<p>If <code>long-ident</code> from <a href="./#named-patterns">§7.2</a> resolves to a union case, the pattern is a union case pattern. If <code>long-ident</code>
resolves to a union case <code>Case</code> , then <code>long-ident</code> and <code>long-ident pat</code> are patterns that match pattern
inputs that have union case label <code>Case</code>. The <code>long-ident</code> form is used if the corresponding case takes
no arguments, and the <code>long-ident pat</code> form is used if it takes arguments.</p>
<p>At runtime, if the pattern input is an object that has the corresponding union case label, the data
values carried by the union are matched against the given argument patterns.</p>
<p>For example:</p>
<pre><code class="language-fsharp">type Data =
    | Kind1 of int * int
    | Kind2 of string * string

let data = Kind1(3, 2)

let result =
    match data with
    | Kind1 (a, b) -&gt; a + b
    | Kind2 (s1, s2) -&gt; s1.Length + s2.Length
</code></pre>
<p>In this case, result is given the value 5.</p>
<p>When a union case has named fields, these names may be referenced in a union case pattem. When
using pattern matching with multiple fields, semicolons are used to delimit the named fields. For
example</p>
<pre><code class="language-fsharp">type Shape =
    | Rectangle of width: float * height: float
    | Square of width: float

let getArea (s: Shape) =
    match s with
    | Rectangle (width = w; height = h) -&gt; w*h
    | Square (width = w) -&gt; w*w
</code></pre>
<h3 id="literal-patterns">Literal Patterns</h3>
<p>If <code>long-ident</code> from <a href="./#named-patterns">§7.2</a> resolves to a literal value, the pattern is a literal pattern. The pattern is
equivalent to the corresponding constant pattern.</p>
<p>In the following example, the <code>Literal</code> attribute (<a href="../namespaces-and-modules/#literal-definitions-in-modules">§10.2.2</a>) is first used to define two literals, and these
literals are used as identifiers in the match expression:</p>
<pre><code class="language-fsharp">[&lt;Literal&gt;]
let Case1 = 1

[&lt;Literal&gt;]
let Case2 = 100

let result =
    match 1 00 with
    | Case1 -&gt; &quot;Case1&quot;
    | Case2 -&gt; &quot;Case 2 &quot;
    | _ -&gt; &quot;Some other case&quot;
</code></pre>
<p>In this case, <code>result</code> is given the value <code>Case2</code>.</p>
<h3 id="active-patterns">Active Patterns</h3>
<p>If <code>long-ident</code> from <a href="./#named-patterns">§7.2</a> resolves to an <em>active pattern case name <code>CaseNamei</code></em> then the pattern is an
active pattern. The rules for name resolution in patterns (<a href="../inference-procedures/#name-resolution-in-patterns">§14.1.6</a>) ensure that <code>CaseNamei</code> is
associated with an <em>active pattern function <code>f</code></em> in one of the following forms:</p>
<ul>
<li><code>(| CaseName |) inp</code></li>
</ul>
<p>Single case. The function accepts one argument (the value being matched) and can return any
type.</p>
<ul>
<li><code>(| CaseName |_|) inp</code></li>
</ul>
<p>Partial. The function accepts one argument (the value being matched) and must return a value
of type <code>FSharp.Core.option&lt;_&gt;</code></p>
<ul>
<li><code>(| CaseName1 | ...| CaseNamen |) inp</code></li>
</ul>
<p>Multi-case. The function accepts one argument (the value being matched), and must return a
value of type <code>FSharp.Core.Choice&lt;_,...,_&gt;</code> based on the number of case names. In F#, the
limitation n ≤ 7 applies.</p>
<ul>
<li><code>(| CaseName |) arg1 ... argn inp</code></li>
</ul>
<p>Single case with parameters. The function accepts <code>n+1</code> arguments, where the last argument (<code>inp</code>)
is the value to match, and can return any type.</p>
<ul>
<li><code>(| CaseName |_|) arg1 ... argn inp</code></li>
</ul>
<p>Partial with parameters. The function accepts n +1 arguments, where the last argument (<code>inp</code>) is
the value to match, and must return a value of type <code>FSharp.Core.option&lt;_&gt;</code>.</p>
<p>Other active pattern functions are not permitted. In particular, multi-case, partial functions such as
the following are not permitted:</p>
<pre><code class="language-fsharp">(|CaseName1| ... |CaseNamen|_|)
</code></pre>
<p>When an active pattern function takes arguments, the <code>pat-params</code> are interpreted as expressions
that are passed as arguments to the active pattern function. The <code>pat-params</code> are converted to the
syntactically identical corresponding expression forms and are passed as arguments to the active
pattern function <code>f</code>.</p>
<p>At runtime, the function <code>f</code> is applied to the pattern input, along with any parameters. The pattern
matches if the active pattern function returns <code>v</code> , <code>ChoicekOfN v</code> , or Some <code>v</code> , respectively, when applied
to the pattern input. If the pattern argument <code>pat</code> is present, it is then matched against <code>v</code>.</p>
<p>The following example shows how to define and use a partial active pattern function:</p>
<pre><code class="language-fsharp">let (|Positive|_|) inp = if inp &gt; 0 then Some(inp) else None
let (|Negative|_|) inp = if inp &lt; 0 then Some(-inp) else None

match 3 with
| Positive n -&gt; printfn &quot;positive, n = %d&quot; n
| Negative n -&gt; printfn &quot;negative, n = %d&quot; n
| _ -&gt; printfn &quot;zero&quot;
</code></pre>
<p>The following example shows how to define and use a multi-case active pattern function:</p>
<pre><code class="language-fsharp">let (|A|B|C|) inp = if inp &lt; 0 then A elif inp = 0 then B else C

match 3 with
| A -&gt; &quot;negative&quot;
| B -&gt; &quot;zero&quot;
| C - &gt; &quot;positive&quot;
</code></pre>
<p>The following example shows how to define and use a parameterized active pattern function:</p>
<pre><code class="language-fsharp">let (|MultipleOf|_|) n inp = if inp%n = 0 then Some (inp / n) else None

match 16 with
| MultipleOf 4 n -&gt; printfn &quot;x = 4*%d&quot; n
| _ -&gt; printfn &quot;not a multiple of 4&quot;
</code></pre>
<p>An active pattern function is executed only if a left-to-right, top-to-bottom reading of the entire
pattern indicates that execution is required. For example, consider the following active patterns:</p>
<pre><code class="language-fsharp">let (|A|_|) x =
    if x = 2 then failwith &quot;x is two&quot;
    elif x = 1 then Some()
    else None

let (|B|_|) x =
    if x=3 then failwith &quot;x is three&quot; else None

let (|C|) x = failwith &quot;got to C&quot;

let f x =
    match x with
    | 0 -&gt; 0
    | A -&gt; 1
    | B -&gt; 2
    | C -&gt; 3
    | _ -&gt; 4
</code></pre>
<p>These patterns evaluate as follows:</p>
<pre><code class="language-fsharp">f 0 // 0
f 1 // 1
f 2 // failwith &quot;x is two&quot;
f 3 // failwith &quot;x is three&quot;
f 4 // failwith &quot;got to C&quot;
</code></pre>
<p>An active pattern function may be executed multiple times against the same pattern input during
resolution of a single overall pattern match. The precise number of times that the active pattern
function is executed against a particular pattern input is implementation-dependent.</p>
<h2 id="as-patterns">“As” Patterns</h2>
<p>An “as” pattern is of the following form:</p>
<pre><code class="language-fsgrammar">pat as ident
</code></pre>
<p>The “as” pattern defines <code>ident</code> to be equal to the pattern input and matches the pattern input
against <code>pat</code>. For example:</p>
<pre><code class="language-fsharp">let t1 = (1, 2)
let (x, y) as t2 = t1
printfn &quot;%d-%d-%A&quot; x y t2 // 1- 2 - (1, 2)
</code></pre>
<p>This example binds the identifiers <code>x</code>, <code>y</code>, and <code>t1</code> to the values <code>1</code> , <code>2</code> , and <code>(1,2)</code>, respectively.</p>
<h2 id="wildcard-patterns">Wildcard Patterns</h2>
<p>The pattern <code>_</code> is a wildcard pattern and matches any input. For example:</p>
<pre><code class="language-fsharp">let categorize x =
    match x with
    | 1 - &gt; 0
    | 0 -&gt; 1
    | _ -&gt; 0
</code></pre>
<p>In the example, if <code>x</code> is <code>0</code>, the match returns <code>1</code>. If <code>x</code> has any other value, the match returns <code>0</code>.</p>
<h2 id="disjunctive-patterns">Disjunctive Patterns</h2>
<p>A disjunctive pattern matches an input value against one or the other of two patterns:</p>
<pre><code class="language-fsgrammar">pat | pat
</code></pre>
<p>At runtime, the pattern input is matched against the first pattern. If that fails, the pattern input is
matched against the second pattern. Both patterns must bind the same set of variables with the
same types. For example:</p>
<pre><code class="language-fsharp">type Date = Date of int * int * int

let isYearLimit date =
    match date with
    | (Date (year, 1, 1) | Date (year, 12, 31)) -&gt; Some year
    | _ -&gt; None

let result = isYearLimit (Date (2010,12,31))
</code></pre>
<p>In this example, <code>result</code> is given the value <code>true</code>, because the pattern input matches the second
pattern.</p>
<h2 id="conjunctive-patterns">Conjunctive Patterns</h2>
<p>A conjunctive pattern matches the pattern input against two patterns.</p>
<pre><code class="language-fsgrammar">pat1 &amp; pat2
</code></pre>
<p>For example:</p>
<pre><code class="language-fsharp">let (|MultipleOf|_|) n inp = if inp%n = 0 then Some (inp / n) else None

let result =
match 56 with
    | MultipleOf 4 m &amp; MultipleOf 7 n -&gt; m + n
    | _ -&gt; false
</code></pre>
<p>In this example, <code>result</code> is given the value <code>22</code> (= 16 + 8), because the pattern input match matches
both patterns.</p>
<h2 id="list-patterns">List Patterns</h2>
<p>The pattern <code>pat :: pat</code> is a union case pattern that matches the “cons” union case of F# list values.</p>
<p>The pattern <code>[]</code> is a union case pattern that matches the “nil” union case of F# list values.</p>
<p>The pattern <code>[ pat1 ; ... ; patn ]</code> is shorthand for a series of <code>::</code> and empty list patterns
<code>pat1 :: ... :: patn :: []</code>.</p>
<p>For example:</p>
<pre><code class="language-fsharp">let rec count x =
    match x with
    | [] -&gt; 0
    | h :: t -&gt; h + count t

let result1 = count [1;2;3]

let result2 =
    match [1;2;3] with
    | [a;b;c] -&gt; a + b + c
    | _ -&gt; 0
</code></pre>
<p>In this example, both <code>result1</code> and <code>result2</code> are given the value <code>6</code>.</p>
<h2 id="type-annotated-patterns">Type-annotated Patterns</h2>
<p>A <em>type-annotated pattern</em> specifies the type of the value to match to a pattern.</p>
<pre><code class="language-fsgrammar">pat : type
</code></pre>
<p>For example:</p>
<pre><code class="language-fsharp">let rec sum xs =
    match xs with
    | [] -&gt; 0
    | (h : int) :: t -&gt; h + sum t
</code></pre>
<p>In this example, the initial type of <code>h</code> is asserted to be equal to <code>int</code> before the pattern <code>h</code> is checked.
Through type inference, this in turn implies that <code>xs</code> and <code>t</code> have static type <code>int list</code>, and <code>sum</code> has
static type
<code>int list -&gt; int</code>.</p>
<h2 id="dynamic-type-test-patterns">Dynamic Type-test Patterns</h2>
<p><em>Dynamic type-test patterns</em> have the following two forms:</p>
<pre><code class="language-fsgrammar">:? type
:? type as ident
</code></pre>
<p>A dynamic type-test pattern matches any value whose runtime type is <code>type</code> or a subtype of <code>type</code>. For
example:</p>
<pre><code class="language-fsharp">let message (x : System.Exception) =
    match x with
    | :? System.OperationCanceledException -&gt; &quot;cancelled&quot;
    | :? System.ArgumentException -&gt; &quot;invalid argument&quot;
    | _ -&gt; &quot;unknown error&quot;
</code></pre>
<p>If the type-test pattern is of the form <code>:? type as ident</code>, then the value is coerced to the given type
and <code>ident</code> is bound to the result. For example:</p>
<pre><code class="language-fsharp">let findLength (x : obj) =
match x with
    | :? string as s -&gt; s.Length
    | _ -&gt; 0
</code></pre>
<p>In the example, the identifier <code>s</code> is bound to the value <code>x</code> with type <code>string</code>.</p>
<p>If the pattern input has type <code>tyin</code>, pattern checking uses the same conditions as both a dynamic type-
test expression <code>e :? type</code> and a dynamic coercion expression <code>e :?&gt; type</code> where <code>e</code> has type <code>tyin</code>. An
error occurs if <code>type</code> cannot be statically determined to be a subtype of the type of the pattern input.
A warning occurs if the type test will always succeed based on <code>type</code> and the static type of the pattern
input.</p>
<p>A warning is issued if an expression contains a redundant dynamic type-test pattern, after any
coercion is applied. For example:</p>
<pre><code class="language-fsharp">match box &quot;3&quot; with
| :? string -&gt; 1
| :? string -&gt; 1 // a warning is reported that this rule is &quot;never matched&quot;
| _ -&gt; 2

match box &quot;3&quot; with
| :? System.IComparable -&gt; 1
| :? string -&gt; 1 // a warning is reported that this rule is &quot;never matched&quot;
| _ -&gt; 2
</code></pre>
<p>At runtime, a dynamic type-test pattern succeeds if and only if the corresponding dynamic type-test
expression <code>e :? ty</code> would return true where <code>e</code> is the pattern input. The value of the pattern is bound
to the results of a dynamic coercion expression <code>e :?&gt; ty</code>.</p>
<h2 id="record-patterns">Record Patterns</h2>
<p>The following is a <em>record pattern</em> :</p>
<pre><code class="language-fsgrammar">{ long-ident1 = pat1 ; ... ; long-identn = patn }
</code></pre>
<p>For example:</p>
<pre><code class="language-fsharp">type Data = { Header:string; Size: int; Names: string list }

let totalSize data =
    match data with
    | { Header = &quot;TCP&quot;; Size = size; Names = names } -&gt; size + names.Length * 12
    | { Header = &quot;UDP&quot;; Size = size } -&gt; size
    | _ -&gt; failwith &quot;unknown header&quot;
</code></pre>
<p>The <code>long-identi</code> are resolved in the same way as field labels for record expressions and must
together identify a single, unique F# record type. Not all record fields for the type need to be
specified in the pattern.</p>
<h2 id="array-patterns">Array Patterns</h2>
<p>An <em>array pattern</em> matches an array of a partciular length:</p>
<pre><code class="language-fsgrammar">[| pat ; ... ; pat |]
</code></pre>
<p>For example:</p>
<pre><code class="language-fsharp">let checkPackets data =
    match data with
    | [| &quot;HeaderA&quot;; data1; data2 |] -&gt; (data1, data2)
    | [| &quot;HeaderB&quot;; data2; data1 |] -&gt; (data1, data2)
    | _ -&gt; failwith &quot;unknown packet&quot;
</code></pre>
<h2 id="null-patterns">Null Patterns</h2>
<p>The <em>null pattern</em> null matches values that are represented by the CLI value null. For example:</p>
<pre><code class="language-fsharp">let path =
    match System.Environment.GetEnvironmentVariable(&quot;PATH&quot;) with
    | null -&gt; failwith &quot;no path set!&quot;
    | res -&gt; res
</code></pre>
<p>Most F# types do not use <code>null</code> as a representation; consequently, the null pattern is generally used
to check values passed in by CLI method calls and properties. For a list of F# types that use <code>null</code> as a
representation, see <a href="../types-and-type-constraints/#nullness">§5.4.8</a>.</p>
<h2 id="guarded-pattern-rules">Guarded Pattern Rules</h2>
<p><em>Guarded pattern rules</em> have the following form:</p>
<pre><code class="language-fsgrammar">pat when expr
</code></pre>
<p>For example:</p>
<pre><code class="language-fsharp">let categorize x =
    match x with
    | _ when x &lt; 0 -&gt; - 1
    | _ when x &lt; 0 -&gt; 1
    | _ -&gt; 0
</code></pre>
<p>The guards on a rule are executed only after the match value matches the corresponding pattern.
For example, the following evaluates to <code>2</code> with no output.</p>
<pre><code class="language-fsharp">match (1, 2) with
| (3, x) when (printfn &quot;not printed&quot;; true) -&gt; 0
| (_, y) -&gt; y
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2005-2025 F# contributors. Made available under the <a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons CC-by 4.0</a> licence.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>