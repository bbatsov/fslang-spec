
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://fsharp.github.io/fslang-spec/inference-procedures/">
      
      
        <link rel="prev" href="../custom-attributes-and-reflection/">
      
      
        <link rel="next" href="../lexical-filtering/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.11">
    
    
      
        <title>Inference Procedures - F# Language Specification</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.4af4bdda.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#inference-procedures" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="F# Language Specification" class="md-header__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            F# Language Specification
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Inference Procedures
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="F# Language Specification" class="md-nav__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    F# Language Specification
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../front-matter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    F# Language Specification
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../introduction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Program Structure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-analysis/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lexical Analysis
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic-grammar-elements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic Grammar Elements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../types-and-type-constraints/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Types and Type Constraints
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../expressions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Expressions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../patterns/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Patterns
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../type-definitions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Type Definitions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../units-of-measure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Units of Measure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespaces-and-modules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Namespaces and Modules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespace-and-module-signatures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Namespace and Module Signatures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure-and-execution/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Program Structure and Execution
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../custom-attributes-and-reflection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Custom Attributes and Reflection
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Inference Procedures
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Inference Procedures
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#name-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Name Resolution">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#name-environments" class="md-nav__link">
    <span class="md-ellipsis">
      Name Environments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-in-module-and-namespace-paths" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution in Module and Namespace Paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#opening-modules-and-namespace-declaration-groups" class="md-nav__link">
    <span class="md-ellipsis">
      Opening Modules and Namespace Declaration Groups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-in-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution in Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-for-members" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution for Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-in-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution in Patterns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-for-types" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution for Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-for-type-variables" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution for Type Variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#field-label-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Field Label Resolution
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolving-application-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      Resolving Application Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Resolving Application Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unqualified-lookup" class="md-nav__link">
    <span class="md-ellipsis">
      Unqualified Lookup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#item-qualified-lookup" class="md-nav__link">
    <span class="md-ellipsis">
      Item-Qualified Lookup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expression-qualified-lookup" class="md-nav__link">
    <span class="md-ellipsis">
      Expression-Qualified Lookup
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#function-application-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Function Application Resolution
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#method-application-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Method Application Resolution
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Method Application Resolution">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#additional-propagation-of-known-type-information-in-f-31" class="md-nav__link">
    <span class="md-ellipsis">
      Additional Propagation of Known Type Information in F# 3.1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conditional-compilation-of-member-calls" class="md-nav__link">
    <span class="md-ellipsis">
      Conditional Compilation of Member Calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implicit-insertion-of-flexibility-for-uses-of-functions-and-members" class="md-nav__link">
    <span class="md-ellipsis">
      Implicit Insertion of Flexibility for Uses of Functions and Members
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constraint-solving" class="md-nav__link">
    <span class="md-ellipsis">
      Constraint Solving
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Constraint Solving">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#solving-equational-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Equational Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solving-subtype-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Subtype Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solving-nullness-struct-and-other-simple-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Nullness, Struct, and Other Simple Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solving-member-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Member Constraints
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Solving Member Constraints">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simulation-of-solutions-for-member-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Simulation of Solutions for Member Constraints
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over-constrained-user-type-annotations" class="md-nav__link">
    <span class="md-ellipsis">
      Over-constrained User Type Annotations
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#checking-and-elaborating-function-value-and-member-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Checking and Elaborating Function, Value, and Member Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Checking and Elaborating Function, Value, and Member Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ambiguities-in-function-and-value-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Ambiguities in Function and Value Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutable-value-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Mutable Value Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#processing-value-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Processing Value Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#processing-function-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Processing Function Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#processing-recursive-groups-of-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Processing Recursive Groups of Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursive-safety-analysis" class="md-nav__link">
    <span class="md-ellipsis">
      Recursive Safety Analysis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generalization" class="md-nav__link">
    <span class="md-ellipsis">
      Generalization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#condensation-of-generalized-types" class="md-nav__link">
    <span class="md-ellipsis">
      Condensation of Generalized Types
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dispatch-slot-inference" class="md-nav__link">
    <span class="md-ellipsis">
      Dispatch Slot Inference
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dispatch-slot-checking" class="md-nav__link">
    <span class="md-ellipsis">
      Dispatch Slot Checking
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#byref-safety-analysis" class="md-nav__link">
    <span class="md-ellipsis">
      Byref Safety Analysis
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#promotion-of-escaping-mutable-locals-to-objects" class="md-nav__link">
    <span class="md-ellipsis">
      Promotion of Escaping Mutable Locals to Objects
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arity-inference" class="md-nav__link">
    <span class="md-ellipsis">
      Arity Inference
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#additional-constraints-on-cli-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Additional Constraints on CLI Methods
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-filtering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lexical Filtering
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../provided-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Provided Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../special-attributes-and-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Special Attributes and Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../the-f-library-fsharpcoredll/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    The F# Library FSharp.Core.dll
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../features-for-ml-compatibility/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Features for ML Compatibility
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#name-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Name Resolution">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#name-environments" class="md-nav__link">
    <span class="md-ellipsis">
      Name Environments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-in-module-and-namespace-paths" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution in Module and Namespace Paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#opening-modules-and-namespace-declaration-groups" class="md-nav__link">
    <span class="md-ellipsis">
      Opening Modules and Namespace Declaration Groups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-in-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution in Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-for-members" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution for Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-in-patterns" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution in Patterns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-for-types" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution for Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name-resolution-for-type-variables" class="md-nav__link">
    <span class="md-ellipsis">
      Name Resolution for Type Variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#field-label-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Field Label Resolution
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolving-application-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      Resolving Application Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Resolving Application Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unqualified-lookup" class="md-nav__link">
    <span class="md-ellipsis">
      Unqualified Lookup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#item-qualified-lookup" class="md-nav__link">
    <span class="md-ellipsis">
      Item-Qualified Lookup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expression-qualified-lookup" class="md-nav__link">
    <span class="md-ellipsis">
      Expression-Qualified Lookup
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#function-application-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Function Application Resolution
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#method-application-resolution" class="md-nav__link">
    <span class="md-ellipsis">
      Method Application Resolution
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Method Application Resolution">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#additional-propagation-of-known-type-information-in-f-31" class="md-nav__link">
    <span class="md-ellipsis">
      Additional Propagation of Known Type Information in F# 3.1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conditional-compilation-of-member-calls" class="md-nav__link">
    <span class="md-ellipsis">
      Conditional Compilation of Member Calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implicit-insertion-of-flexibility-for-uses-of-functions-and-members" class="md-nav__link">
    <span class="md-ellipsis">
      Implicit Insertion of Flexibility for Uses of Functions and Members
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constraint-solving" class="md-nav__link">
    <span class="md-ellipsis">
      Constraint Solving
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Constraint Solving">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#solving-equational-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Equational Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solving-subtype-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Subtype Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solving-nullness-struct-and-other-simple-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Nullness, Struct, and Other Simple Constraints
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solving-member-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Solving Member Constraints
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Solving Member Constraints">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simulation-of-solutions-for-member-constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Simulation of Solutions for Member Constraints
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#over-constrained-user-type-annotations" class="md-nav__link">
    <span class="md-ellipsis">
      Over-constrained User Type Annotations
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#checking-and-elaborating-function-value-and-member-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Checking and Elaborating Function, Value, and Member Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Checking and Elaborating Function, Value, and Member Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ambiguities-in-function-and-value-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Ambiguities in Function and Value Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutable-value-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Mutable Value Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#processing-value-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Processing Value Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#processing-function-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Processing Function Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#processing-recursive-groups-of-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Processing Recursive Groups of Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursive-safety-analysis" class="md-nav__link">
    <span class="md-ellipsis">
      Recursive Safety Analysis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generalization" class="md-nav__link">
    <span class="md-ellipsis">
      Generalization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#condensation-of-generalized-types" class="md-nav__link">
    <span class="md-ellipsis">
      Condensation of Generalized Types
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dispatch-slot-inference" class="md-nav__link">
    <span class="md-ellipsis">
      Dispatch Slot Inference
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dispatch-slot-checking" class="md-nav__link">
    <span class="md-ellipsis">
      Dispatch Slot Checking
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#byref-safety-analysis" class="md-nav__link">
    <span class="md-ellipsis">
      Byref Safety Analysis
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#promotion-of-escaping-mutable-locals-to-objects" class="md-nav__link">
    <span class="md-ellipsis">
      Promotion of Escaping Mutable Locals to Objects
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arity-inference" class="md-nav__link">
    <span class="md-ellipsis">
      Arity Inference
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#additional-constraints-on-cli-methods" class="md-nav__link">
    <span class="md-ellipsis">
      Additional Constraints on CLI Methods
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="inference-procedures">Inference Procedures</h1>
<h2 id="name-resolution">Name Resolution</h2>
<p>The following sections describe how F# resolves names in various contexts.</p>
<h3 id="name-environments">Name Environments</h3>
<p>Each point in the interpretation of an F# program is subject to an environment. The environment
encompasses:</p>
<ul>
<li>All referenced external DLLs (assemblies).</li>
<li>
<p><em>ModulesAndNamespaces</em> : a table that maps <code>long-ident</code>s to a list of signatures. Each signature is
    either a namespace declaration group signature or a module signature.</p>
<p>For example, <code>System.Collections</code> may map to one namespace declaration group signature for
each referenced assembly that contributes to the <code>System.Collections</code> namespace, and to a
module signature, if a module called <code>System.Collections</code> is declared or in a referenced
assembly.</p>
<p>If the program references multiple assemblies, the assemblies are added to the name resolution
environment in the order in which the references appear on the command line. The order is
important only if ambiguities occur in referencing the contents of assemblies—for example, if
two assemblies define the type <code>MyNamespace.C</code>.</p>
</li>
<li>
<p><em>ExprItems</em> : a table that maps names to the following items:</p>
<ul>
<li>A value</li>
<li>A union case for use when constructing data</li>
<li>An active pattern result tag for use when returning results from active patterns</li>
<li>A type name for each class or struct type</li>
</ul>
</li>
<li><em>FieldLabels</em> : a table that maps names to sets of field references for record types</li>
<li><em>PatItems</em> : a table that maps names to the following items:<ul>
<li>A union case, for use when pattern matching on data</li>
<li>An active pattern case name, for use when specifying active patterns</li>
<li>A literal definition</li>
</ul>
</li>
<li>
<p><em>Types</em> : a table that maps names to type definitions. Two queries are supported on this table:</p>
<ul>
<li>
<p>Find a type by name alone. This query may return multiple types. For example, in the default
   type-checking environment, the resolution of <code>System.Tuple</code> returns multiple tuple types.</p>
</li>
<li>
<p>Find a type by name and generic arity <code>n</code>. This query returns at most one type. For example, in
the default type-checking environment, the resolution of <code>System.Tuple</code> with <code>n = 2</code> returns a
single type.</p>
</li>
<li><em>ExtensionsInScope</em> : a table that maps type names to one or more member definitions</li>
</ul>
</li>
</ul>
<p>The dot notation is resolved during type checking by consulting these tables.</p>
<h3 id="name-resolution-in-module-and-namespace-paths">Name Resolution in Module and Namespace Paths</h3>
<p>Given an input <code>long-ident</code> and environment <code>env</code>, <em>Name Resolution in Module and Namespace Paths</em>
computes the result of interpreting <code>long-ident</code> as a module or namespace. The procedure returns a
list of modules and namespace declaration groups.</p>
<p><em>Name Resolution in Module and Namespace Paths</em> proceeds through the following steps:</p>
<ol>
<li>Consult the <em>ModulesAndNamespaces</em> table to resolve the <code>long-ident</code> prefix to a list of modules
    and namespace declaration group signatures.</li>
<li>If any identifiers remain unresolved, recursively consult the declared modules and sub-modules
    of these namespace declaration groups.</li>
<li>Concatenate all the results.</li>
</ol>
<p>If the <code>long-ident</code> starts with the special pseudo-identifier keyword <code>global</code>, the identifier is resolved
by consulting the <em>ModulesAndNamespaces</em> table and ignoring all <code>open</code> directives, including those
implied by <code>AutoOpen</code> attributes.</p>
<p>For example, if the environment contains two referenced DLLs, and each DLL has namespace
declaration groups for the namespaces <code>System</code>, <code>System.Collections</code>, and
<code>System.Collections.Generic</code>, <em>Name Resolution in Module and Namespace Paths</em> for
<code>System.Collections</code> returns the two namespace declaration groups named <code>System.Collections</code>, one
from each assembly.</p>
<h3 id="opening-modules-and-namespace-declaration-groups">Opening Modules and Namespace Declaration Groups</h3>
<p>When a module or namespace declaration group <code>F</code> is opened, the compiler adds items to the name
environment as follows:</p>
<ol>
<li>Add each exception label for each exception type definition (<a href="../type-definitions/#exception-definitions">§8.11</a>) in <code>F</code> to the <em>ExprItems</em> and
    <em>PatItems</em> tables in the original order of declaration in <code>F</code>.</li>
<li>
<p>Add each type definition in the original order of declaration in <code>F</code>. Adding a type definition
    involves the following procedure:</p>
<ul>
<li>If the type is a class or struct type (or an abbreviation of such a type), add the type name to
the <em>ExprItems</em> table.</li>
<li>If the type definition is a record, add the record field labels to the <em>FieldLabels</em> table, unless
the type has the <code>RequireQualifiedAccess</code> attribute.</li>
<li>If the type is a union, add the union cases to the <em>ExprItems</em> and <em>PatItems</em> tables, unless the
type has the <code>RequireQualifiedAccess</code> attribute.</li>
<li>Add the type to the <em>TypeNames</em> table. If the type has a CLI-encoded generic name such as
<code>List`1</code>, add an entry under both <code>List</code> and <code>List`1</code>.</li>
</ul>
</li>
<li>
<p>Add each value in the original order of declaration in <code>F</code> , as follows:</p>
<ul>
<li>Add the value to the <em>ExprItems</em> table.</li>
<li>If any value is an active pattern, add the tags of that active pattern to the <em>PatItems</em> table
according to the original order of declaration.</li>
<li>If the value is a literal, add it to the <em>PatItems</em> table.</li>
<li>Add the member contents of each type extension in <code>Fi</code> to the <em>ExtensionsInScope</em> table according
to the original order of declaration in <code>Fi</code>.</li>
<li>Add each sub-module or sub-namespace declaration group in <code>Fi</code> to the <em>ModulesAndNamespaces</em>
table according to the original order of declaration in <code>Fi</code>.</li>
<li>Open any sub-modules that are marked with the <code>FSharp.Core.AutoOpen</code> attribute.</li>
</ul>
</li>
</ol>
<h3 id="name-resolution-in-expressions">Name Resolution in Expressions</h3>
<p>Given an input <code>long-ident</code> , environment <code>env</code> , and an optional count <code>n</code> of the number of subsequent
type arguments <code>&lt;_, ..., _&gt;</code>, <em>Name Resolution in Expressions</em> computes a result that contains the
interpretation of the <code>long-ident</code> <code>&lt;_, ..., _&gt;</code> prefix as a value or other expression item, and a residue
path <code>rest</code>.</p>
<p>How Name Resolution in Expressions proceeds depends on whether <code>long-ident</code> is a single identifier
or is composed of more than one identifier.</p>
<p>If <code>long-ident</code> is a single identifier <code>ident</code>:</p>
<ol>
<li>Look up <code>ident</code> in the <em>ExprItems</em> table. Return the result and empty <code>rest</code>.</li>
<li>If <code>ident</code> does not appear in the <em>ExprItems</em> table, look it up in the <em>Types</em> table, with generic arity
    that matches <code>n</code> if available. Return this type and empty <code>rest</code>.</li>
<li>If <code>ident</code> does not appear in either the <em>ExprItems</em> table or the <em>Types</em> table, fail.</li>
</ol>
<p>If <code>long-ident</code> is composed of more than one identifier <code>ident.rest</code>, <em>Name Resolution in Expressions</em>
proceeds as follows:</p>
<ol>
<li>If <code>ident</code> exists as a value in the <em>ExprItems</em> table, return the result, with <code>rest</code> as the residue.</li>
<li>
<p>If <code>ident</code> does not exist as a value in the <em>ExprItems</em> table, perform a backtracking search as
    follows:</p>
<ul>
<li>Consider each division of <code>long-ident</code> into <code>[namespace-or-module-path].ident[.rest]</code>, in
which the <code>namespace-or-module-path</code> becomes successively longer.</li>
<li>For each such division, consider each module signature or namespace declaration group
signature <code>F</code> in the list that is produced by resolving <code>namespace-or-module-path</code> by using Name
<em>Resolution in Module and Namespace Paths</em>.</li>
<li>For each such <code>F</code> , attempt to resolve <code>ident[.rest]</code> in the following order. If any resolution
succeeds, then terminate the search:<ul>
<li>A value in <code>F</code>. Return this item and <code>rest</code>.</li>
<li>A union case in <code>F</code>. Return this item and <code>rest</code>.</li>
<li>An exception constructor in <code>F</code>. Return this item and <code>rest</code>.</li>
<li>A type in <code>F</code>. If <code>rest</code> is empty, then return this type; if not, resolve using <em>Name
Resolution for Members</em>.</li>
<li>A [sub-]module in <code>F</code>. Recursively resolve <code>rest</code> against the contents of this module.</li>
</ul>
</li>
<li>
<p>If steps 1 and 2 do not resolve <code>long-ident</code>, look up <code>ident</code> in the <em>Types</em> table.</p>
</li>
<li>
<p>If the generic arity <code>n</code> is available, then look for a type that matches both <code>ident</code> and <code>n</code>.</p>
</li>
<li>If no generic arity <code>n</code> is available, and <code>rest</code> is not empty:<ul>
<li>If the <em>Types</em> table contains a type <code>ident</code> that does not have generic arguments,
resolve to this type.</li>
<li>If the <em>Types</em> table contains a unique type <code>ident</code> that has generic arguments, resolve
to this type. However, if the overall result of the <em>Name Resolution in Expressions</em>
operation is a member, and the generic arguments do not appear in either the
return or argument types of the item, warn that the generic arguments cannot be
inferred from the type of the item.</li>
<li>If neither of the preceding steps resolves the type, give an error.</li>
</ul>
</li>
<li>If rest is empty, return the type, otherwise resolve using <em>Name Resolution for Members</em>.</li>
<li>If steps 1-3 do not resolve <code>long-ident</code>, look up <code>ident</code> in the <em>ExprItems</em> table and return the result
and residue <code>rest</code>.</li>
<li>Otherwise, if <code>ident</code> is a symbolic operator name, resolve to an item that indicates an implicitly
resolved symbolic operator.</li>
<li>Otherwise, fail.</li>
</ul>
</li>
</ol>
<p>If the expression contains ambiguities, <em>Name Resolution in Expressions</em> returns the first result that
the process generates. For example, consider the following cases:</p>
<pre><code class="language-fsharp">module M =
    type C =
        | C of string
        | D of string
        member x.Prop1 = 3
    type Data =
        | C of string
        | E
        member x.Prop1 = 3
        member x.Prop2 = 3
    let C = 5
    open M
    let C = 4
    let D = 6

    let test1 = C               // resolves to the value C
    let test2 = C.ToString()    // resolves to the value C with residue ToString
    let test3 = M.C             // resolves to the value M.C
    let test4 = M.Data.C        // resolves to the union case M.Data.C
    let test5 = M.C.C           // error: first part resolves to the value M.C,
                                // and this contains no field or property &quot;C&quot;
    let test6 = C.Prop1         // error: the value C does not have a property Prop
    let test7 = M.E.Prop2       // resolves to M.E, and then a property lookup
</code></pre>
<p>The following example shows the resolution behavior for type lookups that are ambiguous by
generic arity:</p>
<pre><code class="language-fsharp">module M =
    type C&lt;'T&gt;() =
        static member P = 1

    type C&lt;'T,'U&gt;() =
        static member P = 1

    let _ = new M.C() // gives an error
    let _ = new M.C&lt;int&gt;() // no error, resolves to C&lt;'T&gt;
    let _ = M.C() // gives an error
    let _ = M.C&lt;int&gt;() // no error, resolves to C&lt;'T&gt;
    let _ = M.C&lt;int,int&gt;() // no error, resolves to C&lt;'T,'U&gt;
    let _ = M.C&lt;_&gt;() // no error, resolves to C&lt;'T&gt;
    let _ = M.C&lt;_,_&gt;() // no error, resolves to C&lt;'T,'U&gt;
    let _ = M.C.P // gives an error
    let _ = M.C&lt;_&gt;.P // no error, resolves to C&lt;'T&gt;
    let _ = M.C&lt;_,_&gt;.P // no error, resolves to C&lt;'T,'U&gt;
</code></pre>
<p>The following example shows how the resolution behavior differs slightly if one of the types has no generic arguments.</p>
<pre><code class="language-fsharp">module M =
    type C() =
        static member P = 1

    type C&lt;'T&gt;() =
        static member P = 1

    let _ = new M.C()       // no error, resolves to C
    let _ = new M.C&lt;int&gt;()  // no error, resolves to C&lt;'T&gt;
    let _ = M.C()           // no error, resolves to C
    let _ = M.C&lt; &gt;()        // no error, resolves to C
    let _ = M.C&lt;int&gt;()      // no error, resolves to C&lt;'T&gt;
    let _ = M.C&lt; &gt;()        // no error, resolves to C
    let _ = M.C&lt;_&gt;()        // no error, resolves to C&lt;'T&gt;
    let _ = M.C.P           // no error, resolves to C
let _ = M.C&lt; &gt;.P            // no error, resolves to C
    let _ = M.C&lt;_&gt;.P        // no error, resolves to C&lt;'T&gt;
</code></pre>
<p>In the following example, the procedure issues a warning for an incomplete type. In this case, the
type parameter <code>'T</code> cannot be inferred from the use <code>M.C.P</code>, because <code>'T</code> does not appear at all in the
type of the resolved element <code>M.C&lt;'T&gt;.P</code>.</p>
<pre><code class="language-fsharp">module M =
    type C&lt;'T&gt;() =
        static member P = 1

    let _ = M.C.P // no error, resolves to C&lt;'T&gt;.P, warning given
</code></pre>
<p>The effect of these rules is to prefer value names over module names for single identifiers. For
example, consider this case:</p>
<pre><code class="language-fsharp">let Foo = 1

module Foo =
    let ABC = 2
let x1 = Foo // evaluates to 1
</code></pre>
<p>The rules, however, prefer type names over value names for single identifiers, because type names
appear in the <em>ExprItems</em> table. For example, consider this case:</p>
<pre><code class="language-fsharp">let Foo = 1
type Foo() =
    static member ABC = 2
let x1 = Foo.ABC // evaluates to 2
let x2 = Foo() // evaluates to a new Foo()
</code></pre>
<h3 id="name-resolution-for-members">Name Resolution for Members</h3>
<p><em>Name Resolution for Members</em> is a sub-procedure used to resolve <code>.member-ident[.rest]</code> to a
member, in the context of a particular type <code>type</code>.</p>
<p><em>Name Resolution for Members</em> proceeds through the following steps:</p>
<ol>
<li>
<p>Search the hierarchy of the type from <code>System.Object</code> to <code>type</code>.</p>
</li>
<li>
<p>At each type, try to resolve <code>member-ident</code> to one of the following, in order:</p>
<ul>
<li>A union case of <code>type</code>.</li>
<li>A property group of <code>type</code>.</li>
<li>A method group of <code>type</code>.</li>
<li>A field of <code>type</code>.</li>
<li>An event of <code>type</code>.</li>
<li>A property group of extension members of <code>type</code>, by consulting the <em>ExtensionsInScope</em> table.</li>
<li>A method group of extension members of <code>type</code>, by consulting the <em>ExtensionsInScope</em> table.</li>
<li>A nested type <code>type-nested</code> of <code>type</code>. Recursively resolve <code>.rest</code> if it is present, otherwise return
<code>type-nested</code>.</li>
</ul>
</li>
<li>
<p>At any type, the existence of a property, event, field, or union case named <code>member-ident</code> causes
    any methods or other entities of that same name from base types to be hidden.</p>
</li>
<li>Combine method groups with method groups from base types. For example:</li>
</ol>
<pre><code class="language-fsharp">type A() =
    member this.Foo(i : int) = 0

type B() =
    inherit A()
    member this.Foo(s : string) = 1

let b = new B()
b.Foo(1)        // resolves to method in A
b.Foo(&quot;abc&quot;)    // resolves to method in B
</code></pre>
<h3 id="name-resolution-in-patterns">Name Resolution in Patterns</h3>
<p><em>Name Resolution for Patterns</em> is used to resolve <code>long-ident</code> in the context of pattern expressions.
The <code>long-ident</code> must resolve to a union case, exception label, literal value, or active pattern case
name. If it does not, the <code>long-ident</code> may represent a new variable definition in the pattern.</p>
<p><em>Name Resolution for Patterns</em> follows the same steps to resolve the <code>member-ident</code> as <em>Name
Resolution in Expressions</em> (<a href="./#name-resolution-in-expressions">§14.1.4</a>) except that it consults the <em>PatItems</em> table instead of the <em>ExprItems</em>
table. As a result, values are not present in the namespace that is used to resolve identifiers in
patterns. For example:</p>
<pre><code class="language-fsharp">let C = 3
match 4 with
| C -&gt; sprintf &quot;matched, C = %d&quot; C
| _ -&gt; sprintf &quot;no match, C = %d&quot; C
</code></pre>
<p>results in <code>"matched, C = 4"</code>, because <code>C</code> is <em>not</em> present in the <em>PatItems</em> table, and hence becomes a
value pattern. In contrast,</p>
<pre><code class="language-fsharp">[&lt;Literal&gt;]
let C = 3

match 4 with
| C -&gt; sprintf &quot;matched, C = %d&quot; C
| _ -&gt; sprintf &quot;no match, C = %d&quot; C
</code></pre>
<p>results in <code>"no match, C = 3"</code>, because <code>C</code> is a literal and therefore <em>is</em> present in the <em>PatItems</em> table.</p>
<h3 id="name-resolution-for-types">Name Resolution for Types</h3>
<p><em>Name Resolution for Types</em> is used to resolve <code>long-ident</code> in the context of a syntactic type. A generic
arity that matches <code>n</code> is always available. The result is a type definition and a possible residue <code>rest</code>.</p>
<p><em>Name Resolution for Types</em> proceeds through the following steps:</p>
<ol>
<li>Given <code>ident[.rest]</code>, look up <code>ident</code> in the <em>Types</em> table, with generic arity <code>n</code>. Return the result and
    residue <code>rest</code>.</li>
<li>
<p>If <code>ident</code> is not present in the <em>Types</em> table:</p>
<ul>
<li>Divide <code>long-ident</code> into <code>[namespace-or-module-path].ident[.rest]</code>, in which the <code>namespace-
or-module-path</code> becomes successively longer.</li>
<li>For each such division, consider each module and namespace declaration group <code>F</code> in the list
that results from resolving <code>namespace-or-module-path</code> by using <em>Name Resolution in Module
and Namespace Paths</em> (<a href="./#name-resolution-in-module-and-namespace-paths">§14.1.2</a>).</li>
<li>For each such <code>F</code> , attempt to resolve <code>ident[.rest]</code> in the following order. Terminate the
search when the expression is successfully resolved.
    1) A type in <code>F</code>. Return this type and residue <code>rest</code>.
    2) A [sub-]module in <code>F</code>. Recursively resolve <code>rest</code> against the contents of this module.</li>
</ul>
</li>
</ol>
<p>In the following example, the name <code>C</code> on the last line resolves to the named type <code>M.C&lt;_,_&gt;</code> because <code>C</code>
is applied to two type arguments:</p>
<pre><code class="language-fsharp">module M =
    type C&lt;'T, 'U&gt; = 'T * 'T * 'U

module N =
    type C&lt;'T&gt; = 'T * 'T

open M
open N

let x : C&lt;int, string&gt; = (1, 1, &quot;abc&quot;)
</code></pre>
<h3 id="name-resolution-for-type-variables">Name Resolution for Type Variables</h3>
<p>Whenever the F# compiler processes syntactic types and expressions, it assumes a context that
maps identifiers to inference type variables. This mapping ensures that multiple uses of the same
type variable name map to the same type inference variable. For example, consider the following
function:</p>
<pre><code class="language-fsharp">let f x y = (x:'T), (y:'T)
</code></pre>
<p>In this case, the compiler assigns the identifiers <code>x</code> and <code>y</code> the same static type - that is, the same type
inference variable is associated with the name <code>'T</code>. The full inferred type of the function is:</p>
<pre><code class="language-fsharp">val f&lt;'T&gt; : 'T -&gt; 'T -&gt; 'T * 'T
</code></pre>
<p>The map is used throughout the processing of expressions and types in a left-to-right order. It is
initially empty for any member or any other top-level construct that contains expressions and types.
Entries are eliminated from the map after they are generalized. As a result, the following code
checks correctly:</p>
<pre><code class="language-fsharp">let f () =
    let g1 (x:'T) = x
    let g2 (y:'T) = (y:string)
    g1 3, g1 &quot;3&quot;, g2 &quot;4&quot;
</code></pre>
<p>The compiler generalizes <code>g1</code>, which is applied to both integer and string types. The type variable <code>'T</code> in
<code>(y:'T)</code> on the third line refers to a different type inference variable, which is eventually constrained to
be type <code>string</code>.</p>
<h3 id="field-label-resolution">Field Label Resolution</h3>
<p><em>Field Label Resolution</em> specifies how to resolve identifiers such as <code>field1</code> in <code>{field1 = expr; ... fieldN = expr}</code>.</p>
<p><em>Field Label Resolution</em> proceeds through the following steps:</p>
<ol>
<li>Look up all fields in all available types in the <em>Types</em> table and the <em>FieldLabels</em> table (<a href="../type-definitions/#record-type-definitions">§8.4</a>).</li>
<li>Return the set of field declarations.</li>
</ol>
<h2 id="resolving-application-expressions">Resolving Application Expressions</h2>
<p>Application expressions that use dot notation - such as <code>x.Y&lt;int&gt;.Z(g).H.I.j</code> - are resolved
according to a set of rules that take into account the many possible shapes and forms of these
expressions and the ambiguities that may occur during their resolution. This section specifies the
exact algorithmic process that is used to resolve these expressions.</p>
<p>Resolution of application expressions proceeds as follows:</p>
<ol>
<li>Repeatedly decompose the application expression into a leading expression <code>expr</code> and a list of
    projections <code>projs</code>. Each projection has the following form:<ul>
<li><code>.long-ident-or-op</code> is a dot lookup projection.</li>
<li><code>expr</code> is an application projection.</li>
<li><code>&lt;types&gt;</code> is a type application projection.</li>
</ul>
</li>
</ol>
<p>For example:
    - <code>x.y.Z(g).H.I.j</code> decomposes into <code>x.y.Z</code> and projections <code>(g)</code>, <code>.H.I.j</code>.
    - <code>x.M&lt;int&gt;(g)</code> decomposes into <code>x.M</code> and projections <code>&lt;int&gt;</code>, <code>(g)</code>.
    - <code>f x</code> decomposes into <code>f</code> and projection <code>x</code>.</p>
<pre><code>&gt; Note: In this specification we write sequences of projections by juxtaposition; for
example, `(expr).long-ident&lt;types&gt;(expr)`. We also write ( `.rest` + `projs` ) to refer to
adding a residue long identifier to the front of a list of projections, which results in `projs`
if `rest` is empty and `.rest projs` otherwise.
</code></pre>
<ol>
<li>After decomposition:<ul>
<li>If <code>expr</code> is a long identifier expression <code>long-ident</code>, apply <em>Unqualified Lookup</em> (<a href="./#unqualified-lookup">§14.2.1</a>) on <code>long-ident</code> with projections <code>projs</code>.</li>
<li>If <code>expr</code> is not such an expression, check the expression against an arbitrary initial type <code>ty</code>, to
   generate an elaborated expression <code>expr</code>. Then process <code>expr</code>, <code>ty</code>, and <code>projs</code> by using
   <em>Expression-Qualified Lookup</em> (<a href="./#expression-qualified-lookup">§14.2.3</a>)</li>
</ul>
</li>
</ol>
<h3 id="unqualified-lookup">Unqualified Lookup</h3>
<p>Given an input <code>long-ident</code> and projections <code>projs</code>, <em>Unqualified Lookup</em> computes the result of
“looking up” <code>long-ident.projs</code> in an environment <code>env</code>. The first part of this process resolves a prefix
of the information in <code>long-ident.projs</code>, and recursive resolutions typically use <em>Expression-Qualified
Resolution</em> to resolve the remainder.</p>
<p>For example, <em>Unqualified Lookup</em> is used to resolve the vast majority of identifier references in F#
code, from simple identifiers such as <code>sin</code>, to complex accesses such as
<code>System.Environment.GetCommandLineArgs().Length</code>.</p>
<p><em>Unqualified Lookup</em> proceeds through the following steps:</p>
<ol>
<li>Resolve <code>long-ident</code> by using <em>Name Resolution in Expressions</em> (<a href="./#name-resolution">§14.1</a>). This returns a <em>name resolution item</em> <code>item</code> and a <em>residue long identifier</em> <code>rest</code>.</li>
</ol>
<p>For example, the result of <em>Name Resolution in Expressions</em> for <code>v.X.Y</code> may be a value reference <code>v</code>
along with a residue long identifier <code>X.Y</code>. Likewise, <code>N.X(args).Y</code> may resolve to an overloaded
method <code>N.X</code> and a residue long identifier <code>Y</code>.</p>
<p><em>Name Resolution in Expressions</em> also takes as input the presence and count of subsequent type
arguments in the first projection. If the first projection in <code>projs</code> is <code>&lt;tyargs&gt;</code>, <em>Unqualified Lookup</em>
invokes <em>Name Resolution in Expressions</em> with a known number of type arguments. Otherwise, it
is invoked with an unknown number of type arguments.</p>
<ol>
<li>Apply <em>Item-Qualified Lookup</em> for <code>item</code> and (<code>rest</code> + <code>projs</code>).</li>
</ol>
<h3 id="item-qualified-lookup">Item-Qualified Lookup</h3>
<p>Given an input item <code>item</code> and projections <code>projs</code>, <em>Item-Qualified Lookup</em> computes the projection
<code>item.projs</code>. This computation is often a recursive process: the first resolution uses a prefix of the
information in <code>item.projs</code>, and recursive resolutions resolve any remaining projections.</p>
<p><em>Item-Qualified Lookup</em> proceeds as follows:</p>
<ol>
<li>If <code>item</code> is not one of the following, return an error:<ul>
<li>A named value</li>
<li>A union case</li>
<li>A group of named types</li>
<li>A group of methods</li>
<li>A group of indexer getter properties</li>
<li>A single non-indexer getter property</li>
<li>A static F# field</li>
<li>A static CLI field</li>
<li>An implicitly resolved symbolic operator name</li>
</ul>
</li>
<li>If the first projection is <code>&lt;types&gt;</code>, then we say the resolution has a type application <code>&lt;types&gt;</code> with
    remaining projections.</li>
<li>
<p>Otherwise, checking proceeds as follows.</p>
<ul>
<li>
<p>If <code>item</code> is a value reference <code>v</code> then first
Instantiate the type scheme of <code>v</code>, which results in a type <code>ty</code>. Apply these rules:</p>
<ul>
<li>If the first projection is <code>&lt;types&gt;</code>, process the types and use the results as the
arguments to instantiate the type scheme.</li>
<li>If the first projection is not <code>&lt;types&gt;</code>, the type scheme is <em>freshly instantiated</em>.</li>
<li>If the value has the <code>RequiresExplicitTypeArguments</code> attribute, the first
projection must be <code>&lt;types&gt;</code>.</li>
<li>If the value has type <code>byref&lt;ty2&gt;</code>, add a byref dereference to the elaborated
expression.</li>
<li>Insert implicit flexibility for the use of the value (<a href="./#implicit-insertion-of-flexibility-for-uses-of-functions-and-members">§14.4.3</a>).</li>
</ul>
<p>Then Apply <em>Expression-Qualified Lookup</em> for type <code>ty</code> and any remaining projections.</p>
</li>
<li>
<p>If <code>item</code> is a type name, where <code>projs</code> begins with <code>&lt;types&gt;.long-ident</code></p>
<ul>
<li>Process the types and use the results as the arguments to instantiate the named
type reference, thus generating a type <code>ty</code>.</li>
<li>Apply <em>Name Resolution for Members</em> to <code>ty</code> and <code>long-ident</code>, which generates a new
<code>item</code>.</li>
<li>Apply <em>Item-Qualified Lookup</em> to the new <code>item</code> and any remaining projections.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a group of type names where <code>projs</code> begins with <code>&lt;types&gt;</code> or <code>expr</code> or <code>projs</code> is empty</p>
<ul>
<li>Process the types and use the results as the arguments to instantiate the named
type reference, thus generating a type <code>ty</code>.</li>
<li>Process the object construction <code>ty(expr)</code> as an object constructor call in the same
way as <code>new ty(expr)</code>. If <code>projs</code> is empty then process the object construction <code>ty</code> as
an object constructor call in the same way as <code>(fun arg -&gt; new ty(arg))</code>, i.e.
resolve the object constructor call with no arguments.</li>
<li>Apply <em>Expression-Qualified Lookup</em> to <code>item</code> and any remaining projections.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a group of method references</p>
<ul>
<li>Apply <em>Method Application Resolution</em> for the method group. <em>Method Application Resolution</em> 
  accepts an optional set of type arguments and a syntactic expression
    argument. Determine the arguments based on what <code>projs</code> begins with:<ul>
<li><code>&lt;types&gt; expr</code>, then use <code>&lt;types&gt;</code> as the type arguments and <code>expr</code> as the
   expression argument.</li>
<li><code>expr</code>, then use <code>expr</code> as the expression argument.</li>
<li>anything else, use no expression argument or type arguments.</li>
</ul>
</li>
<li>If the result of <em>Method Application Resolution</em> is labeled with the
    <code>RequiresExplicitTypeArguments</code> attribute, then explicit type arguments are
    required.</li>
<li>Let <code>fty</code> be the actual return type that results from <em>Method Application Resolution</em>.
    Apply <em>Expression-Qualified Lookup</em> to <code>fty</code> and any remaining projections.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a group of property indexer references</p>
<ul>
<li>Apply <em>Method Application Resolution</em>, and use the underlying getter indexer
methods for the method group.</li>
<li>Determine the arguments to <em>Method Application Resolution</em> as described for a
group of methods.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a static field reference</p>
<ul>
<li>Check the field for accessibility and attributes.</li>
<li>Let <code>fty</code> be the actual type of the field, taking into account the type <code>ty</code> via which the
  field was accessed in the case where this is a field in a generic type.</li>
<li>Apply <em>Expression-Qualified Lookup</em> to <code>fty</code> and <code>projs</code>.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a union case tag, exception tag, or active pattern result element tag</p>
<ul>
<li>Check the tag for accessibility and attributes.</li>
<li>If <code>projs</code> begins with <code>expr</code>, use <code>expr</code> as the expression argument.</li>
<li>Otherwise, use no expression argument or type arguments. In this case, build a
  function expression for the union case.</li>
<li>Let <code>fty</code> be the actual type of the union case.</li>
<li>Apply <em>Expression-Qualified Lookup</em> to <code>fty</code> and remaining <code>projs</code>.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a CLI event reference</p>
<ul>
<li>Check the event for accessibility and attributes.</li>
<li>Let <code>fty</code> be the actual type of the event.</li>
<li>Apply <em>Expression-Qualified Lookup</em> to <code>fty</code> and <code>projs</code>.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is an implicitly resolved symbolic operator name <code>op</code></p>
<ul>
<li>
<p>If <code>op</code> is a unary, binary or the ternary operator ?&lt;-, resolve to the following
expressions, respectively:</p>
<p><code>fsharp
(fun (x:^a) -&gt; (^a : static member (op) : ^a -&gt; ^b) x)
(fun (x:^a) (y:^b) -&gt;
    ((^a or ^b) : static member (op) : ^a * ^b -&gt; ^c) (x,y))
(fun (x:^a) (y:^b) (z:^c)
    -&gt; ((^a or ^b or ^c) : static member (op) : ^a * ^b * ^c -&gt; ^d) (x,y,z))</code>
        - The resulting expressions are static member constraint invocation expressions (<a href="../expressions/#member-constraint-invocation-expressions">§6.4.8</a>),
        which enable the default interpretation of operators by using type-directed
        member resolution.
        - Recheck the entire expression with additional subsequent projections <code>.projs</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="expression-qualified-lookup">Expression-Qualified Lookup</h3>
<p>Given an elaborated expression <code>expr</code> of type <code>ty</code>, and projections <code>projs</code>, <em>Expression-Qualified Lookup</em>
computes the “lookups or applications” for <code>expr.projs</code>.</p>
<p>Expression-Qualified Lookup proceeds through the following steps:</p>
<ol>
<li>
<p>Inspect <code>projs</code> and process according to the following table.</p>
<table>
<thead>
<tr>
<th><code>projs</code></th>
<th>Action</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>Empty</td>
<td>Assert that the type of the overall, original application expression is <code>ty</code>.</td>
<td>Checking is complete.</td>
</tr>
<tr>
<td>Starts with <code>(expr2)</code></td>
<td>Apply <em>Function Application Resolution</em> (<a href="./#function-application-resolution">§14.3</a>).</td>
<td>Checking is complete when <em>Function Application Resolution</em> returns.</td>
</tr>
<tr>
<td>Starts with <code>&lt;types&gt;</code></td>
<td>Fail.</td>
<td>Type instantiations may not be applied to arbitrary expressions; they can apply only to generic types, generic methods, and generic values.</td>
</tr>
<tr>
<td>Starts with <code>.long-ident</code></td>
<td>Resolve <code>long-ident</code> using <em>Name Resolution for Members</em> (<a href="./#name-resolution-in-expressions">§14.1.4</a>)_. Return a name resolution item <code>item</code> and a residue long identifier <code>rest</code>. Continue processing at step 2.</td>
<td>For example, for <code>ty = string</code> and <code>long-ident = Length</code>, <em>Name Resolution for Members</em> returns a property reference to the CLI instance property <code>System.String.Length</code>.</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>If Step 1 returned an <code>item</code> and <code>rest</code>, report an error if <code>item</code> is not one of the following:</p>
<ul>
<li>A group of methods.</li>
<li>A group of instance getter property indexers.</li>
<li>A single instance, non-indexer getter property.</li>
<li>A single instance F# field.</li>
<li>A single instance CLI field.</li>
</ul>
</li>
<li>
<p>Proceed based on <code>item</code> as follows:</p>
<ul>
<li>
<p>If <code>item</code> is a group of methods</p>
<ul>
<li>
<p>Apply <em>Method Application Resolution</em> for the method group. <em>Method Application Resolution</em> accepts an optional set of type arguments and a syntactic expression argument. If <code>projs</code> begins with:</p>
<ul>
<li><code>&lt;types&gt;(arg)</code>, then use <code>&lt;types&gt;</code> as the type arguments and <code>arg</code> as
the expression argument.</li>
<li><code>(arg)</code>, then use <code>arg</code> as the expression argument.</li>
<li>otherwise, use no expression argument or type arguments.</li>
</ul>
</li>
<li>
<p>Let <code>fty</code> be the actual return type resulting from <em>Method Application Resolution</em>. Apply <em>Expression-Qualified Lookup</em> to <code>fty</code> and any remaining projections.</p>
</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a group of indexer properties</p>
<ul>
<li>Apply <em>Method Application Resolution</em> and use the underlying getter indexer methods for the method group.</li>
<li>Determine the arguments to <em>Method Application Resolution</em> as described for a group of methods.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is a non-indexer getter property</p>
<ul>
<li>Apply <em>Method Application Resolution</em> for the method group that contains
    only the getter method for the property, with no type arguments and one <code>()</code> argument.</li>
</ul>
</li>
<li>
<p>If <code>item</code> is an instance intermediate language (IL) or F# field <code>F</code></p>
<ul>
<li>Check the field for accessibility and attributes.</li>
<li>Let <code>fty</code> be the actual type of the field (taking into account the type <code>ty</code>
  by which the field was accessed).</li>
<li>Assert that <code>ty</code> is a subtype of the actual containing type of the field.</li>
<li>Produce an elaborated form for <code>expr.F</code>. If <code>F</code> is a field in a value type
  then take the address of <code>expr</code> by using the <em>AddressOf</em>(<code>expr, NeverMutates</code>) operation <a href="../expressions/#taking-the-address-of-an-elaborated-expression">§6.9.4</a>.</li>
<li>Apply <em>Expression-Qualified Lookup</em> to <code>fty</code> and <code>projs</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="function-application-resolution">Function Application Resolution</h2>
<p>Given expressions <code>f</code> and <code>expr</code> where <code>f</code> has type <code>ty</code>, and given subsequent projections <code>projs</code>, <em>Function
Application Resolution</em> does the following:</p>
<ol>
<li>Asserts that <code>f</code> has type <code>ty1 -&gt; ty2</code> for new inference variables <code>ty1</code> and <code>ty2</code>.</li>
<li>
<p>If the assertion succeeds:</p>
<ul>
<li>Check <code>expr</code> with the initial type <code>ty1</code>.</li>
<li>Process <code>projs</code> using <em>Expression-Qualified Lookup</em> against <code>ty2</code>.</li>
<li>
<p>If the assertion fails, and <code>expr</code> has the form <code>{ computation-expr }</code>:</p>
</li>
<li>
<p>Check the expression as the computation expression form <code>f { computation-expr }</code>, giving result type <code>ty1</code>.</p>
</li>
<li>Process <code>projs</code> using Expression-Qualified Lookup against <code>ty1</code>.</li>
</ul>
</li>
</ol>
<h2 id="method-application-resolution">Method Application Resolution</h2>
<p>Given a method group <code>M</code>, optional type arguments <code>&lt;ActualTypeArgs&gt;</code>, an optional syntactic argument
<code>obj</code>, an optional syntactic argument <code>arg</code>, and overall initial type <code>ty</code>, <em>Method Application Resolution</em>
resolves the overloading based on the partial type information that is available. It also:</p>
<ul>
<li>Resolves optional and named arguments.</li>
<li>Resolves “out” arguments.</li>
<li>Resolves post-hoc property assignments.</li>
<li>Applies method application resolution.</li>
<li>Inserts <em>ad hoc</em> conversions that are only applied for method calls.</li>
</ul>
<p>If no syntactic argument is supplied, <em>Method Application Resolution</em> tries to resolve the use of the
method as a first class value, such as the method call in the following example:</p>
<pre><code class="language-fsharp">List.map System.Environment.GetEnvironmentVariable [&quot;PATH&quot;; &quot;USERNAME&quot;]
</code></pre>
<p><em>Method Application Resolution</em> proceeds through the following steps:</p>
<ol>
<li>Restrict the candidate method group <code>M</code> to those methods that are <em>accessible</em> from the point of
    resolution.</li>
<li>
<p>If an argument <code>arg</code> is present, determine the sets of <em>unnamed</em> and <em>named actual arguments</em>,
    <code>UnnamedActualArgs</code> and <code>NamedActualArgs</code>:</p>
<ul>
<li>
<p>Decompose <code>arg</code> into a list of arguments:</p>
<ul>
<li>If <code>arg</code> is a syntactic tuple <code>arg1, ..., argN</code>, use these arguments.</li>
<li>If <code>arg</code> is a syntactic unit value <code>()</code>, use a zero-length list of arguments.</li>
</ul>
</li>
<li>
<p>For each argument:</p>
<ul>
<li>If <code>arg</code> is a binary expression of the form <code>name=expr</code>, it is a named actual argument.</li>
<li>Otherwise, <code>arg</code> is an unnamed actual argument.</li>
</ul>
</li>
</ul>
<p>If there are no named actual arguments, and <code>M</code> has only one candidate method, which accepts
only one required argument, ignore the decomposition of <code>arg</code> to tuple form. Instead, <code>arg</code> itself is
the only named actual argument.</p>
<p>All named arguments must appear after all unnamed arguments.</p>
<p>Examples:
- <code>x.M(1, 2)</code> has two unnamed actual arguments.
- <code>x.M(1, y = 2)</code> has one unnamed actual argument and one named actual argument.
- <code>x.M(1, (y = 2))</code> has two unnamed actual arguments.
- <code>x.M( printfn "hello"; ())</code> has one unnamed actual argument.
- <code>x.M((a, b))</code> has one unnamed actual argument.
- <code>x.M(())</code> has one unnamed actual argument.</p>
</li>
<li>
<p>Determine the named and unnamed <em>prospective actual argument types</em>, called <code>ActualArgTypes</code>.</p>
<ul>
<li>If an argument <code>arg</code> is present, the prospective actual argument types are fresh type
   inference variables for each unnamed and named actual argument.</li>
<li>If the argument has the syntactic form of an address-of expression <code>&amp;expr</code> after ignoring
      parentheses around the argument, equate this type with a type <code>byref&lt;ty&gt;</code> for a fresh
      type <code>ty</code>.</li>
<li>If the argument has the syntactic form of a function expression <code>fun pat1 ... patn -&gt; expr</code>
      after ignoring parentheses around the argument, equate this type with a 
      type <code>ty1 -&gt; ... tyn -&gt; rty</code> for fresh types <code>ty1 ... tyn</code>.</li>
<li>
<p>If no argument <code>arg</code> is present:</p>
<ul>
<li>If the method group contains a single method, the prospective unnamed argument
types are one fresh type inference variable for each required, non-“out” parameter that
the method accepts.</li>
<li>
<p>If the method group contains more than one method, the expected overall type of the
expression is asserted to be a function type <code>dty -&gt; rty</code>.</p>
<ul>
<li>
<p>If <code>dty</code> is a tuple type <code>(dty1 * ... * dtyN)</code>, the prospective argument types are <code>(dty1,
..., dtyN)</code>.</p>
</li>
<li>
<p>If <code>dty</code> is <code>unit</code>, then the prospective argument types are an empty list.</p>
</li>
<li>
<p>If <code>dty</code> is any other type, the prospective argument types are <code>dty</code> alone.</p>
</li>
</ul>
</li>
<li>
<p>Subsequently:</p>
<ul>
<li>
<p>The method application is considered to have one unnamed actual argument for
each prospective unnamed actual argument type.</p>
</li>
<li>
<p>The method application is considered to have no named actual arguments.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>For each candidate method in <code>M</code>, attempt to produce zero, one, or two <em>prospective method calls</em>
    <code>M~possible</code> as follows:</p>
<ul>
<li>If the candidate method is generic and has been generalized, generate fresh type inference
variables for its generic parameters. This results in the <code>FormalTypeArgs</code> for <code>M~possible</code>.</li>
<li>Determine the named and unnamed formal parameters , called <code>NamedFormalArgs</code> and
<code>UnnamedFormalArgs</code> respectively, by splitting the formal parameters for <code>M</code> into parameters
that have a matching argument in <code>NamedActualArgs</code> and parameters that do not.</li>
<li>
<p>If the number of <code>UnnamedFormalArgs</code> exceeds the number of <code>UnnamedActualArgs</code>, then modify
<code>UnnamedFormalArgs</code> as follows:</p>
<ul>
<li>Determine the suffix of <code>UnnamedFormalArgs</code> beyond the number of <code>UnnamedActualArgs</code>.</li>
<li>If all formal parameters in the suffix are <code>out</code> arguments with <code>byref</code> type, remove the
    suffix from <code>UnnamedFormalArgs</code> and call it <code>ImplicitlyReturnedFormalArgs</code>.</li>
<li>If all formal parameters in the suffix are optional arguments, remove the suffix from
    <code>UnnamedFormalArgs</code> and call it <code>ImplicitlySuppliedFormalArgs</code>.</li>
</ul>
</li>
<li>
<p>If the last element of <code>UnnamedFormalArgs</code> has the <code>ParamArray</code> attribute and type <code>pty[]</code> for
some <code>pty</code>, then modify <code>UnnamedActualArgs</code> as follows:</p>
<ul>
<li>If the number of <code>UnnamedActualArgs</code> exceeds the number of <code>UnnamedFormalArgs - 1</code>,
    produce a prospective method call named <code>ParamArrayActualArgs</code> that has the excess of
    <code>UnnamedActualArgs</code> removed.</li>
<li>
<p>If the number of <code>UnnamedActualArgs</code> equals the number of <code>UnnamedFormalArgs - 1</code>, produce
    two prospective method calls:</p>
<ul>
<li>One has an empty <code>ParamArrayActualArgs</code>.</li>
<li>One has no <code>ParamArrayActualArgs</code>.</li>
</ul>
</li>
<li>
<p>If <code>ParamArrayActualArgs</code> has been produced, then <code>M~possible</code> is said to use <em>ParamArray conversion</em> with type <code>pty</code>.</p>
</li>
</ul>
</li>
<li>
<p>Associate each <code>name = arg</code> in <code>NamedActualArgs</code> with a target. A target is a <em>named formal
  parameter</em>, a <em>settable return property</em>, or a <em>settable return field</em> as follows:</p>
<ul>
<li>If one of the arguments in <code>NamedFormalArgs</code> has name <code>name</code>, that argument is the target.</li>
<li>If the return type of <code>M</code>, before the application of any type arguments <code>ActualTypeArgs</code>,
    contains a settable property <code>name</code>, then <code>name</code> is the target. The available properties
    include any property extension members of type, found by consulting the
    <em>ExtensionsInScope</em> table.</li>
<li>If the return type of <code>M</code>, before the application of any type arguments <code>ActualTypeArgs</code>,
    contains a settable field <code>name</code>, then <code>name</code> is the target.</li>
</ul>
</li>
<li>
<p>No prospective method call is generated if any of the following are true:</p>
<ul>
<li>A named argument cannot be associated with a target.</li>
<li>The number of <code>UnnamedActualArgs</code> is less than the number of <code>UnnamedFormalArgs</code> after
    steps 4 a-e.</li>
<li>The number of <code>ActualTypeArgs</code>, if any actual type arguments are present, does not
    precisely equal the number of <code>FormalTypeArgs</code> for <code>M</code>.</li>
<li>The candidate method is static and the optional syntactic argument <code>obj</code> is present, or
    the candidate method is an instance method and <code>obj</code> is not present.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Attempt to apply initial types before argument checking. If only one prospective method call
<code>M~possible</code> exists, <em>assert</em> <code>M~possible</code> by performing the following steps:</p>
<ul>
<li>Verify that each <code>ActualTypeArgi</code> is equal to its corresponding <code>FormalTypeArgi</code>.</li>
<li>Verify that the type of <code>obj</code> is a subtype of the containing type of the method <code>M</code>.</li>
<li>For each <code>UnnamedActualArgi</code> and <code>UnnamedFormalArgi</code>, verify that the corresponding
<code>ActualArgType</code> coerces to the type of the corresponding argument of <code>M</code>.</li>
<li>If <code>M~possible</code> uses ParamArray conversion with type <code>pty</code>, then for each <code>ParamArrayActualArgi</code>,
verify that the corresponding <code>ActualArgType</code> coerces to <code>pty</code>.</li>
<li>For each <code>NamedActualArgi</code> that has an associated formal parameter target, verify that the
corresponding <code>ActualArgType</code> coerces to the type of the corresponding argument of <code>M</code>.</li>
<li>For each <code>NamedActualArgi</code> that has an associated property or field setter target, verify that
the corresponding <code>ActualArgType</code> coerces to the type of the property or field.</li>
<li>
<p>Verify that the prospective formal return type coerces to the expected actual return type. If
the method <code>M</code> has return type <code>rty</code>, the formal return type is defined as follows:</p>
<ul>
<li>If the prospective method call contains <code>ImplicitlyReturnedFormalArgs</code> with type <code>ty1, ..., tyN</code>,
  the formal return type is <code>rty * ty1 * ... * tyN</code>. If <code>rty</code> is <code>unit</code> then the formal
    return type is <code>ty1 * ... * tyN</code>.</li>
<li>Otherwise the formal return type is <code>rty</code>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check and elaborate argument expressions. If <code>arg</code> is present:</p>
<ul>
<li>Check and elaborate each unnamed actual argument expression <code>argi</code>. Use the
corresponding type in <code>ActualArgTypes</code> as the initial type.</li>
<li>Check and elaborate each named actual argument expression <code>argi</code>. Use the corresponding
type in <code>ActualArgTypes</code> as the initial type.</li>
</ul>
</li>
<li>
<p>Choose a unique <code>M~possible</code> according to the following rules:</p>
<ul>
<li>For each <code>M~possible</code>, determine whether the method is <em>applicable</em> by attempting to assert
<code>M~possible</code> as described in step 4a). If the actions in step 4a detect an inconsistent constraint set
(<a href="./#constraint-solving">§14.5</a>), the method is not applicable. Regardless, the overall constraint set is left unchanged
as a result of determining the applicability of each <code>M~possible</code>.</li>
<li>
<p>If a unique applicable <code>M~possible</code> exists, choose that method. Otherwise, choose the unique <em>best</em>
<code>M~possible</code> by applying the following criteria, in order:
    1) Prefer candidates whose use does not constrain the use of a user-introduced generic
    type annotation to be equal to another type.
    2) Prefer candidates that do not use ParamArray conversion. If two candidates both use
    ParamArray conversion with types <code>pty1</code> and <code>pty2</code>, and <code>pty1</code> feasibly subsumes <code>pty2</code>, prefer
    the second; that is, use the candidate that has the more precise type.
    3) Prefer candidates that do not have <code>ImplicitlyReturnedFormalArgs</code>.
    4) Prefer candidates that do not have <code>ImplicitlySuppliedFormalArgs</code>.
    5) If two candidates have unnamed actual argument types <code>ty11 ... ty1n</code> and <code>ty21 ... ty2n</code>, and
       each <code>ty1i</code> either
        - feasibly subsumes <code>ty2i</code>, or
        - <code>ty2i</code> is a <code>System.Func</code> type and <code>ty1i</code> is some other delegate type,</p>
<p>then prefer the second candidate. That is, prefer any candidate that has the more
   specific actual argument types, and consider any <code>System.Func</code> type to be more specific
   than any other delegate type.
6) Prefer candidates that are not extension members over candidates that are.
7) To choose between two extension members, prefer the one that results from the most
recent use of open.
8) Prefer candidates that are not generic over candidates that are generic - that is, prefer
candidates that have empty <code>ActualArgTypes</code>.</p>
</li>
</ul>
<p>Report an error if steps 1) through 8) do not result in the selection of a unique better method.</p>
</li>
<li>
<p>Once a unique best <code>M~possible</code> is chosen, commit that method.</p>
</li>
<li>Apply attribute checks.</li>
<li>
<p>Build the resulting elaborated expression by following these steps:</p>
<ul>
<li>If the type of <code>obj</code> is a variable type or a value type, take the address of <code>obj</code> by using the
<em>AddressOf</em><code>(obj , PossiblyMutates)</code> operation (<a href="../expressions/#taking-the-address-of-an-elaborated-expression">§6.9.4</a>).</li>
<li>
<p>Build the argument list by:</p>
<ul>
<li>Passing each argument corresponding to an <code>UnamedFormalArgs</code> where the argument is an
    optional argument as a <code>Some</code> value.</li>
<li>Passing a <code>None</code> value for each argument that corresponds to an <code>ImplicitlySuppliedFormalArgs</code>.</li>
<li>Applying coercion to arguments.</li>
</ul>
</li>
<li>
<p>Bind <code>ImplicitlyReturnedFormalArgs</code> arguments by introducing mutable temporaries for each
argument, passing them as <code>byref</code> parameters, and building a tuple from these mutable
temporaries and any method return value as the overall result.</p>
</li>
<li>For each <code>NamedActualArgs</code> whose target is a settable property or field, assign the value into
the property.</li>
<li>If <code>arg</code> is not present, return a function expression that represents a first class function value.</li>
</ul>
</li>
</ol>
<p>Two additional rules apply when checking arguments (see <a href="../type-definitions/#type-directed-conversions-at-member-invocations">§8.13.7</a> for examples):</p>
<ul>
<li>
<p>If a formal parameter has delegate type <code>D</code>, an actual argument <code>farg</code> has known type
      <code>ty1 -&gt; ... -&gt; tyn -&gt; rty</code>, and the number of arguments of the Invoke method of delegate type
      <code>D</code> is precisely <code>n</code>, interpret the formal parameter in the same way as the following:
         <code>new D (fun arg1 ... argn -&gt; farg arg1 ... argn)</code>.</p>
<p>For more information on the conversions that are automatically applied to arguments, see
  <a href="../type-definitions/#optional-arguments-to-method-members">§8.13.6</a>.</p>
</li>
<li>
<p>If a formal parameter is an <code>out</code> parameter of type <code>byref&lt;ty&gt;</code>, and an actual argument type is
      not a byref type, interpret the actual parameter in the same way as type <code>ref&lt;ty&gt;</code>. That is, an F#
      reference cell can be passed where a <code>byref&lt;ty&gt;</code> is expected.</p>
</li>
</ul>
<p>One effect of these additional rules is that a method that is used as a first class function value can
resolve even if a method is overloaded and no further information is available. For example:</p>
<pre><code class="language-fsharp">let r = new Random()
let roll = r.Next;;
</code></pre>
<p><em>Method Application Resolution</em> results in the following, despite the fact that in the standard CLI
library, <code>System.Random.Next</code> is overloaded:</p>
<pre><code class="language-fsharp">val roll : int -&gt; int
</code></pre>
<p>The reason is that if the initial type contains no information about the expected number of
arguments, the F# compiler assumes that the method has one argument.</p>
<h3 id="additional-propagation-of-known-type-information-in-f-31">Additional Propagation of Known Type Information in F# 3.1</h3>
<p>In the above descreiption of F# overload resolution, the argument expressions of a call to an
overloaded set of methods</p>
<pre><code class="language-fsgrammar">callerObjArgTy.Method(callerArgExpr1 , ... callerArgExprN)
</code></pre>
<p>calling</p>
<pre><code class="language-fsgrammar">calledObjArgTy.Method(calledArgTy1, ... calledArgTyN)
</code></pre>
<p>In F# 3.1 and subsequently, immediately prior to checking argument expressions, each argument
position of the unnamed caller arguments for the method call is analysed to propagate type
information extracted from method overloads to the expected types of lambda expressions. The
new rule is applied when</p>
<ul>
<li>the candidates are overloaded</li>
<li>the caller argument at the given unnamed argument position is a syntactic lambda, possible
    parenthesized</li>
<li>
<p>all the corresponding formal called arguments have <code>calledArgTy</code> either of</p>
<ul>
<li>function type <code>calledArgDomainTy1 -&gt; ... -&gt; calledArgDomainTyN -&gt; calledArgRangeTy</code>
    (after taking into account “function to delegate” adjustments), or</li>
<li>some other type which would cause an overload to be discarded</li>
</ul>
</li>
<li>
<p>at least one overload has enough curried lambda arguments for it corresponding expected
    function type</p>
</li>
</ul>
<p>In this case, for each unnamed argument position, then for each overload:</p>
<ul>
<li>Attempt to solve <code>callerObjArgTy = calledObjArgTy</code> for the overload, if the overload is for an
    instance member. When making this application, only solve type inference variables present in
    the <code>calledObjArgTy</code>. If any of these conversions fail, then skip the overload for the purposes of
    this rule</li>
<li>Attempt to solve <code>callerArgTy = (calledArgDomainTy1_ -&gt; ... -&gt; calledArgDomainTyN_ -&gt; ?)</code>. If
    this fails, then skip the overload for the purposes of this rule</li>
</ul>
<h3 id="conditional-compilation-of-member-calls">Conditional Compilation of Member Calls</h3>
<p>If a member definition has the <code>System.Diagnostics.Conditional</code> attribute, then any application of
the member is adjusted as follows:</p>
<ul>
<li>The <code>Conditional("symbol")</code> attribute may apply to methods only.</li>
<li>Methods that have the <code>Conditional</code> attribute must have return type <code>unit</code>. The return type may
    be checked either on use of the method or definition of the method.</li>
<li>If <code>symbol</code> is not in the current set of conditional compilation symbols, the compiler eliminates
    application expressions that resolve to calls to members that have the <code>Conditional</code> attribute and
    ensures that arguments are not evaluated. Elimination of such expressions proceeds first with
    static members and then with instance members, as follows:<ul>
<li>Static members: <code>Type.M(args)</code> =&gt; <code>()</code></li>
<li>Instance members: <code>expr.M(args)</code> =&gt; <code>()</code></li>
</ul>
</li>
</ul>
<h3 id="implicit-insertion-of-flexibility-for-uses-of-functions-and-members">Implicit Insertion of Flexibility for Uses of Functions and Members</h3>
<p>At each use of a data constructor, named function, or member that forms an expression, flexibility is
implicitly added to the expression. This flexibility is associated with the use of the function or
member, according to the inferred type of the expression. The added flexibility allows the item to
accept arguments that are statically known to be subtypes of argument types to a function without
requiring explicit upcasts</p>
<p>The flexibility is added by adjusting each expression <code>expr</code> which represents a use of a function or
member as follows:</p>
<ul>
<li>
<p>The type of the function or member is decomposed to the following form:</p>
<p><code>fsgrammar
ty11 * ... * ty1n -&gt; ... -&gt; tym1 * ... * tymn -&gt; rty</code>
- If the type does not decompose to this form, no flexibility is added.
- The positions <code>tyij</code> are called the “parameter positions” for the type. For each parameter position
where <code>tyij</code> is not a sealed type, and is not a variable type, the type is replaced by a fresh type
variable <code>ty'ij</code> with a coercion constraint <code>ty'ij :&gt; tyij</code>.
- After the addition of flexibility, the expression elaborates to an expression of type</p>
<p><code>fsgrammar
ty'11 * ... * ty'1n -&gt; ... -&gt; ty'm1 * ... * ty'mn -&gt; rty</code></p>
<p>but otherwise is semantically equivalent to <code>expr</code> by creating an anonymous function expression
and inserting appropariate coercions on arguments where necessary.</p>
</li>
</ul>
<p>This means that F# functions whose inferred type includes an unsealed type in argument position
may be passed subtypes when called, without the need for explicit upcasts. For example:</p>
<pre><code class="language-fsharp">type Base() =
    member b.X = 1

type Derived(i : int) =
    inherit Base()
    member d.Y = i

let d = new Derived(7)

let f (b : Base) = b.X

// Call f: Base -&gt; int with an instance of type Derived
let res = f d

// Use f as a first-class function value of type : Derived -&gt; int
let res2 = (f : Derived -&gt; int)
</code></pre>
<p>The F# compiler determines whether to insert flexibility after explicit instantiation, but before any
arguments are checked. For example, given the following:</p>
<pre><code class="language-fsharp">let M&lt;'b&gt;(c :'b, d :'b) = 1
let obj = new obj()
let str = &quot;&quot;
</code></pre>
<p>these expressions pass type-checking:</p>
<pre><code class="language-fsharp">M&lt;obj&gt;(obj, str)
M&lt;obj&gt;(str, obj)
M&lt;obj&gt;(obj, obj)
M&lt;obj&gt;(str, str)
M(obj, obj)
M(str, str)
</code></pre>
<p>These expressions do not, because the target type is a variable type:</p>
<pre><code class="language-fsharp">M(obj, str)
M(str, obj)
</code></pre>
<h2 id="constraint-solving">Constraint Solving</h2>
<p>Constraint solving involves processing (“solving”) non-primitive constraints to reduce them to
primitive, normalized constraints on type variables. The F# compiler invokes constraint solving every
time it adds a constraint to the set of current inference constraints at any point during type
checking.</p>
<p>Given a type inference environment, the <em>normalized form</em> of constraints is a list of the following
primitive constraints where <code>typar</code> is a type inference variable:</p>
<pre><code class="language-fsother">typar :&gt; type
typar : null
( type or ... or type ) : ( member-sig )
typar : (new : unit -&gt; 'T)
typar : struct
typar : unmanaged
typar : comparison
typar : equality
typar : not struct
typar : enum&lt; type &gt;
typar : delegate&lt; type, type &gt;
</code></pre>
<p>Each newly introduced constraint is solved as described in the following sections.</p>
<h3 id="solving-equational-constraints">Solving Equational Constraints</h3>
<p>New equational constraints in the form <code>typar = type</code> or <code>type = typar</code> , where <code>typar</code> is a type
inference variable, cause <code>type</code> to replace <code>typar</code> in the constraint problem; <code>typar</code> is eliminated. Other
constraints that are associated with <code>typar</code> are then no longer primitive and are solved again.</p>
<p>New equational constraints of the form <code>type&lt;tyarg11,..., tyarg1n&gt; = type&lt;tyarg21, ..., tyarg2n&gt;</code>
are reduced to a series of constraints <code>tyarg1i = tyarg2i</code> on identical named types and solved again.</p>
<h3 id="solving-subtype-constraints">Solving Subtype Constraints</h3>
<p>Primitive constraints in the form <code>typar :&gt; obj</code> are discarded.</p>
<p>New constraints in the form <code>type1 :&gt; type2</code>, where <code>type2</code> is a sealed type, are reduced to the
constraint <code>type1</code> = <code>type2</code> and solved again.</p>
<p>New constraints in either of these two forms are reduced to the constraints 
<code>tyarg11 = tyarg 21 ... tyarg1n = tyarg2n</code> and solved again:</p>
<pre><code class="language-fsother">type&lt;tyarg11, ..., tyarg1n&gt; :&gt; type&lt;tyarg21, ..., tyarg2n&gt;
type&lt;tyarg11, ..., tyarg1n&gt; = type&lt;tyarg21, ..., tyarg2n&gt;
</code></pre>
<blockquote>
<p>Note: F# generic types do not support covariance or contravariance. That is, although
single-dimensional array types in the CLI are effectively covariant, F# treats these types
as invariant during constraint solving. Likewise, F# considers CLI delegate types as
invariant and ignores any CLI variance type annotations on generic interface types and
generic delegate types.</p>
</blockquote>
<p>New constraints of the form <code>type1&lt;tyarg11, ..., tyarg1n&gt; :&gt; type2&lt;tyarg21, ..., tyarg2n&gt;</code> where
<code>type1</code> and <code>type2</code> are hierarchically related, are reduced to an equational constraint on two
instantiations of <code>type2</code> according to the subtype relation between <code>type1</code> and <code>type2</code>, and solved again.</p>
<p>For example, if <code>MySubClass&lt;'T&gt;</code> is derived from <code>MyBaseClass&lt;list&lt;'T&gt;&gt;</code>, then the constraint</p>
<pre><code class="language-fsother">MySubClass&lt;'T&gt; :&gt; MyBaseClass&lt;int&gt;
</code></pre>
<p>is reduced to the constraint</p>
<pre><code class="language-fsother">MyBaseClass&lt;list&lt;'T&gt;&gt; :&gt; MyBaseClass&lt;list&lt;int&gt;&gt;
</code></pre>
<p>and solved again, so that the constraint <code>'T = int</code> will eventually be derived.</p>
<blockquote>
<p>Note : Subtype constraints on single-dimensional array types <code>ty[] :&gt; ty</code> are reduced to
residual constraints, because these types are considered to be subtypes of <code>System.Array</code>,
<code>System.Collections.Generic.IList&lt;'T&gt;</code>, <code>System.Collections.Generic.ICollection&lt;'T&gt;</code>,
and <code>System.Collections.Generic.IEnumerable&lt;'T&gt;</code>. Multidimensional array types
<code>ty[,...,]</code> are also subtypes of <code>System.Array</code>.
<br>Types from other CLI languages may, in theory, support multiple instantiations of the
same interface type, such as <code>C : I&lt;int&gt;, I&lt;string&gt;</code>. Consequently, it is more difficult to
solve a constraint such as <code>C :&gt; I&lt;'T&gt;</code>. Such constraints are rarely used in practice in F#
coding. To solve this constraint, the F# compiler reduces it to a constraint <code>C :&gt; I&lt;'T&gt;</code>,
where <code>I&lt;'T&gt;</code> is the first interface type that occurs in the tree of supported interface
types, when the tree is ordered from most derived to least derived, and iterated left-to-
right in the order of the declarations in the CLI metadata.
<br>The F# compiler ignores CLI variance type annotations on interfaces.</p>
</blockquote>
<p>New constraints of the form <code>type :&gt; 'b</code> are solved again as <code>type = 'b</code>.</p>
<blockquote>
<p>Note : Such constraints typically occur only in calls to generic code from other CLI
languages where a method accepts a parameter of a “naked” variable type—for
example, a C# 2.0 function with a signature such as <code>T Choose&lt;'T&gt;(T x, T y)</code>.</p>
</blockquote>
<h3 id="solving-nullness-struct-and-other-simple-constraints">Solving Nullness, Struct, and Other Simple Constraints</h3>
<p>New constraints in any of the following forms, where <code>type</code> is not a variable type, are reduced to
further constraints:</p>
<pre><code class="language-fsother">type : null
type : (new : unit -&gt; 'T)
type : struct
type : not struct
type : enum&lt; type &gt;
type : delegate&lt; type, type &gt;
type : unmanaged
</code></pre>
<p>The compiler then resolves them according to the requirements for each kind of constraint listed in
<a href="../types-and-type-constraints/#type-constraints">§5.2</a> and <a href="../types-and-type-constraints/#nullness">§5.4.8</a>.</p>
<h3 id="solving-member-constraints">Solving Member Constraints</h3>
<p>New constraints in the following form are solved as <em>member constraints</em> (<a href="../types-and-type-constraints/#member-constraints">§5.2.3</a>):</p>
<pre><code class="language-fsother">(type1 or ... or typen) : (member-sig)
</code></pre>
<p>A member constraint is satisfied if one of the types in the <em>support set</em> <code>type1 ... typen</code> satisfies the
member constraint. A static type <code>type</code> satisfies a member constraint in the form
<code>(static~opt member ident : arg-type1 * ... * arg-typen -&gt; ret-type)</code>
if all of the following are true:</p>
<ul>
<li><code>type</code> is a named type whose type definition contains the following member, which takes <code>n</code>
    arguments:
    <code>static~opt member ident : formal-arg-type1 * ... * formal-arg-typen -&gt; ret-type</code></li>
<li>The <code>type</code> and the constraint are both marked <code>static</code> or neither is marked <code>static</code>.</li>
<li>The assertion of type inference constraints on the arguments and return types does not result in
    a type inference error.</li>
</ul>
<p>As mentioned in <a href="../types-and-type-constraints/#member-constraints">§5.2.3</a>, a type variable may not be involved in the support set of more than one
member constraint that has the same name, staticness, argument arity, and support set. If a type
variable is in the support set of more than one such constraint, the argument and return types are
themselves constrained to be equal.</p>
<h4 id="simulation-of-solutions-for-member-constraints">Simulation of Solutions for Member Constraints</h4>
<p>Certain types are assumed to implicitly define static members even though the actual CLI metadata
for types does not define these operators. This mechanism is used to implement the extensible
conversion and math functions of the F# library including <code>sin</code>, <code>cos</code>, <code>int</code>, <code>float</code>, <code>(+)</code>, and <code>(-)</code>. The
following table shows the static members that are implicitly defined for various types.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Implicitly defined static members</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integral types:<br> <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>nativeint</code>, <code>unativeint</code></td>
<td><code>op_BitwiseAnd</code>, <code>op_BitwiseOr</code>, <code>op_ExclusiveOr</code>, <code>op_LeftShift</code>, <code>op_RightShift</code>, <code>op_UnaryPlus</code>, <code>op_UnaryNegation</code>, <code>op_Increment</code>, <code>op_Decrement</code>, <code>op_LogicalNot</code>, <code>op_OnesComplement</code>, <code>op_Addition</code>, <code>op_Subtraction</code>, <code>op_Multiply</code>, <code>op_Division</code>, <code>op_Modulus</code>, <code>op_UnaryPlus</code><br><code>op_Explicit</code>: takes the type as an argument and returns <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code>, <code>decimal</code>, <code>nativeint</code>, or <code>unativeint</code></td>
</tr>
<tr>
<td>Signed integral CLI types:<br> <code>sbyte</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> and <code>nativeint</code></td>
<td><code>op_UnaryNegation</code>, <code>Sign</code>, <code>Abs</code></td>
</tr>
<tr>
<td>Floating-point CLI types:<br><code>float32</code> and <code>float</code></td>
<td><code>Sin</code>, <code>Cos</code>, <code>Tan</code>, <code>Sinh</code>, <code>Cosh</code>, <code>Tanh</code>, <code>Atan</code>, <code>Acos</code>, <code>Asin</code>, <code>Exp</code>, <code>Ceiling</code>, <code>Floor</code>, <code>Round</code>, <code>Log10</code>, <code>Log</code>, <code>Sqrt</code>, <code>Atan2</code>, <code>Pow</code>, <code>op_Addition</code>, <code>op_Subtraction</code>, <code>op_Multiply</code>, <code>op_Division</code>, <code>op_Modulus</code>, <code>op_UnaryPlus</code>, <code>op_UnaryNegation</code>, <code>Sign</code>, <code>Abs</code> <br> <code>op_Explicit</code>: takes the type as an argument and returns <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code>, <code>decimal</code>, <code>nativeint</code>, or <code>unativeint</code></td>
</tr>
<tr>
<td>decimal type <br><strong>Note</strong> : The decimal type is included only for the Sign static member. This is deliberate: in the CLI, <code>System.Decimal</code> includes the definition of static members such as <code>op_Addition</code> and the F# compiler does not need to simulate the existence of these methods.</td>
<td><code>Sign</code></td>
</tr>
<tr>
<td>String type <code>string</code></td>
<td><code>op_Addition</code> <br> <code>op_Explicit</code>: takes the type as an argument and return <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code> or <code>decimal</code>.</td>
</tr>
</tbody>
</table>
<h3 id="over-constrained-user-type-annotations">Over-constrained User Type Annotations</h3>
<p>An implementation of F# must give a warning if a type inference variable that results from a user
type annotation is constrained to be a type other than another type inference variable. For example,
the following results in a warning because <code>'T</code> has been constrained to be precisely <code>string</code>:</p>
<pre><code class="language-fsharp">let f (x:'T) = (x:string)
</code></pre>
<p>During the resolution of overloaded methods, resolutions that do not give such a warning are
preferred over resolutions that do give such a warning.</p>
<h2 id="checking-and-elaborating-function-value-and-member-definitions">Checking and Elaborating Function, Value, and Member Definitions</h2>
<p>This section describes how function, value, and member definitions are checked, generalized, and
elaborated. These definitions occur in the following contexts:</p>
<ul>
<li>Module declarations</li>
<li>Class type declarations</li>
<li>Expressions</li>
<li>Computation expressions</li>
</ul>
<p>Recursive definitions can also occur in each of these locations. In addition, member definitions in a
mutually recursive group of type declarations are implicitly recursive.</p>
<p>Each definition is one of the following:</p>
<ul>
<li>
<p>A function definition :</p>
<p><code>fsgrammar
inline~opt ident1 pat1 ... patn :~opt return-type~opt = rhs-expr</code>
- A value definition, which defines one or more values by matching a pattern against an expression:
<code>fsgrammar
mutable~opt pat :~opt type~opt = rhs-expr</code>
- A member definition:</p>
<p><code>fsgrammar
static~opt member ident~opt ident pat1 ... patn = expr</code>
For a function, value, or member definition in a class:</p>
</li>
<li>
<p>If the definition is an instance function, value or member, checking uses an environment to
    which both of the following have been added:</p>
<ul>
<li>The instance variable for the class, if one is present.</li>
<li>All previous function and value definitions for the type, whether static or instance.</li>
</ul>
</li>
<li>If the definition is static (that is, a static function, value or member defeinition), checking uses an
    environment to which all previous static function, value, and member definitions for the type
    have been added.</li>
</ul>
<h3 id="ambiguities-in-function-and-value-definitions">Ambiguities in Function and Value Definitions</h3>
<p>In one case, an ambiguity exists between the syntax for function and value definitions. In particular,
<code>ident pat = expr</code> can be interpreted as either a function or value definition. For example, consider
the following:</p>
<pre><code class="language-fsharp">type OneInteger = Id of int

let Id x = x
</code></pre>
<p>In this case, the ambiguity is whether <code>Id x</code> is a pattern that matches values of type <code>OneInteger</code> or is
the function name and argument list of a function called <code>Id</code>. In F# this ambiguity is always resolved
as a function definition. In this case, to make a value definition, use the following syntax in which the
ambiguous pattern is enclosed in parentheses:</p>
<pre><code class="language-fsharp">let v = if 3 = 4 then Id &quot;yes&quot; else Id &quot;no&quot;
let (Id answer) = v
</code></pre>
<h3 id="mutable-value-definitions">Mutable Value Definitions</h3>
<p>Value definitions may be marked as mutable. For example:</p>
<pre><code class="language-fsharp">let mutable v = 0
while v &lt; 10 do
    v &lt;- v + 1
    printfn &quot;v = %d&quot; v
</code></pre>
<p>These variables are implicitly dereferenced when used.</p>
<h3 id="processing-value-definitions">Processing Value Definitions</h3>
<p>A value definition <code>pat = rhs-expr</code> with optional pattern type <code>type</code> is processed as follows:</p>
<ol>
<li>The pattern <code>pat</code> is checked against a fresh initial type <code>ty</code> (or <code>type</code> if such a type is present). This
    check results in zero or more identifiers <code>ident1 ... identm</code>, each of type <code>ty1</code> ... <code>tym</code>.</li>
<li>The expression <code>rhs-expr</code> is checked against initial type <code>ty</code>, resulting in an elaborated form <code>expr</code>.</li>
<li>Each <code>identi</code> (of type <code>tyi</code>) is then generalized (<a href="./#generalization">§14.6.7</a>) and yields generic parameters <code>&lt;typarsj&gt;</code>.</li>
<li>The following rules are checked:<ul>
<li>All <code>identj</code> must be distinct.</li>
<li>Value definitions may not be <code>inline</code>.</li>
</ul>
</li>
<li>
<p>If <code>pat</code> is a single value pattern, the resulting elaborated definition is:</p>
<p><code>fsgrammar
ident&lt;typars1&gt; = expr
body-expr</code>
6. Otherwise, the resulting elaborated definitions are the following, where <code>tmp</code> is a fresh identifier
and each <code>expri</code> results from the compilation of the pattern <code>pat</code> (<a href="../patterns/#patterns">§7</a>) against input <code>tmp</code>.</p>
<p><code>fsgrammar
tmp&lt;typars1 ... typarsn&gt; = expr
ident1&lt;typars1&gt; = expr1
...
identn&lt;typarsn&gt; = exprn</code></p>
<h3 id="processing-function-definitions">Processing Function Definitions</h3>
</li>
</ol>
<p>A function definition <code>ident1 pat1 ... patn = rhs-expr</code> is processed as follows:</p>
<ol>
<li>If <code>ident1</code> is an active pattern identifier then active pattern result tags are added to the
    environment (<a href="../namespaces-and-modules/#active-pattern-definitions-in-modules">§10.2.4</a>).</li>
<li>The expression <code>(fun pat1 ... patn : return-type -&gt; rhs-expr)</code> is checked against a fresh initial
    type <code>ty1</code> and reduced to an elaborated form <code>expr1</code>. The return type is omitted if the definition
    does not specify it.</li>
<li>The <code>ident1</code> (of type <code>ty1</code>) is then generalized (<a href="./#generalization">§14.6.7</a>) and yields generic parameters <code>&lt;typars1&gt;</code>.</li>
<li>The following rules are checked:<ul>
<li>Function definitions may not be <code>mutable</code>. Mutable function values should be written as follows:
<code>fsother
let mutable f = (fun args -&gt; ...)`</code></li>
<li>The patterns of functions may not include optional arguments (<a href="../type-definitions/#optional-arguments-to-method-members">§8.13.6</a>).</li>
</ul>
</li>
<li>
<p>The resulting elaborated definition is:</p>
<p><code>fsgrammar
ident1&lt;typars1&gt; = expr1</code></p>
<h3 id="processing-recursive-groups-of-definitions">Processing Recursive Groups of Definitions</h3>
</li>
</ol>
<p>A group of functions and values may be declared recursive through the use of <code>let rec</code>. Groups of
members in a recursive set of type definitions are also implicitly recursive. In this case, the defined
values are available for use within their own definitions—that is, within all the expressions on the
right-hand side of the definitions.</p>
<p>For example:</p>
<pre><code class="language-fsharp">let rec twoForward count =
    printfn &quot;at %d, taking two steps forward&quot; count
    if count = 1000 then &quot;got there!&quot;
    else oneBack (count + 2)
and oneBack count =
    printfn &quot;at %d, taking one step back &quot; count
    twoForward (count – 1)
</code></pre>
<p>When one or more definitions specifies a value, the recursive expressions are analyzed for safety
(<a href="./#recursive-safety-analysis">§14.6.6</a>). This analysis may result in warnings—including some reported at compile time—and
runtime checks.</p>
<p>Within recursive groups, each definition in the group is checked (<a href="./#generalization">§14.6.7</a>) and then the definitions
are generalized incrementally. In addition, any use of an ungeneralized recursive definition results in
immediate constraints on the recursively defined construct. For example, consider the following
declaration:</p>
<pre><code class="language-fsharp">let rec countDown count x =
    if count &gt; 0 then
        let a = countDown (count - 1) 1 // constrains &quot;x&quot; to be of type int
        let b = countDown (count – 1) &quot;Hello&quot; // constrains &quot;x&quot; to be of type string
        a + b
    else
        1
</code></pre>
<p>In this example, the definition is not valid because the recursive uses of <code>f</code> result in inconsistent
constraints on <code>x</code>.</p>
<p>If a definition has a full signature, early generalization applies and recursive calls at different types
are permitted (<a href="./#generalization">§14.6.7</a>). For example:</p>
<pre><code class="language-fsharp">module M =
    let rec f&lt;'T&gt; (x:'T) : 'T =
        let a = f 1
        let b = f &quot;Hello&quot;
        x
</code></pre>
<p>In this example, the definition is valid because <code>f</code> is subject to early generalization, and so the
recursive uses of <code>f</code> do not result in inconsistent constraints on <code>x</code>.</p>
<h3 id="recursive-safety-analysis">Recursive Safety Analysis</h3>
<p>A set of recursive definitions may include value definitions. For example:</p>
<pre><code class="language-fsharp">type Reactor = React of (int -&gt; React) * int

let rec zero = React((fun c -&gt; zero), 0)

let const n =
    let rec r = React((fun c -&gt; r), n)
    r
</code></pre>
<p>Recursive value definitions may result in invalid recursive cycles, such as the following:</p>
<pre><code class="language-fsharp">let rec x = x + 1
</code></pre>
<p>The <em>Recursive Safety Analysis</em> process partially checks the safety of these definitions and convert
thems to a form that uses lazy initialization, where runtime checks are inserted to check
initialization.</p>
<p>A right-hand side expression is <em>safe</em> if it is any of the following:</p>
<ul>
<li>A function expression, including those whose bodies include references to variables that are
    defined recursively.</li>
<li>An object expression that implements an interface, including interfaces whose member bodies
    include references to variables that are being defined recursively.</li>
<li>A <code>lazy</code> delayed expression.</li>
<li>A record, tuple, list, or data construction expression whose field initialization expressions are all
    safe.</li>
<li>A value that is not being recursively bound.</li>
<li>
<p>A value that is being recursively bound and appears in one of the following positions:</p>
<ul>
<li>As a field initializer for a field of a record type where the field is marked <code>mutable</code>.</li>
<li>As a field initializer for an immutable field of a record type that is defined in the current
   assembly.
   If record fields contain recursive references to values being bound, the record fields must be
   initialized in the same order as their declared type, as described later in this section.</li>
</ul>
</li>
<li>
<p>Any expression that refers only to earlier variables defined by the sequence of recursive
    definitions.</p>
</li>
</ul>
<p>Other right-hand side expressions are elaborated by adding a new definition. If the original definition
is</p>
<pre><code class="language-fsharp">u = expr
</code></pre>
<p>then a fresh value (say v) is generated with the definition:</p>
<pre><code class="language-fsharp">v = lazy expr
</code></pre>
<p>and occurrences of the original variable <code>u</code> on the right-hand side are replaced by <code>Lazy.force v</code>. The
following definition is then added at the end of the definition list:</p>
<pre><code class="language-fsharp">u = v .Force()
</code></pre>
<blockquote>
<p>Note: This specification implies that recursive value definitions are executed as an
initialization graph of delayed computations. Some recursive references may be checked
at runtime because the computations that are involved in evaluating the definitions
might actually execute the delayed computations. The F# compiler gives a warning for
recursive value definitions that might involve a runtime check. If runtime self-reference
does occur then an exception will be raised.
<br>Recursive value definitions that involve computation are useful when defining objects
such as forms, controls, and services that respond to various inputs. For example, GUI
elements that store and retrieve the state of the GUI elements as part of their
specification typically involve recursive value definitions. A simple example is the
following menu item, which prints out part of its state when invoked:</p>
</blockquote>
<pre><code class="language-fsharp">open System.Windows.Form
let rec menuItem : MenuItem =
    new MenuItem(&quot;&amp;Say Hello&quot;,
                 new EventHandler(fun sender e -&gt;
                     printfn &quot;Text = %s&quot; menuItem.Text),
                 Shortcut.CtrlH)
</code></pre>
<blockquote>
<p>This code results in a compiler warning because, in theory, the
<code>new MenuItem(...)</code> constructor might evaluate the callback as part of the construction
process. However, because the <code>System.Windows.Forms</code> library is well designed, in this
example this does not happen in practice, and so the warning can be suppressed or
ignored by using compiler options.</p>
</blockquote>
<p>The F# compiler performs a simple approximate static analysis to determine whether immediate
cyclic dependencies are certain to occur during the evaluation of a set of recursive value definitions.
The compiler creates a graph of definite references and reports an error if such a dependency cycle
exists. All references within function expressions, object expressions, or delayed expressions are
assumed to be indefinite, which makes the analysis an under-approximation. As a result, this check
catches naive and direct immediate recursion dependencies, such as the following:</p>
<pre><code class="language-fsharp">let rec A = B + 1
and B = A + 1
</code></pre>
<p>Here, a compile-time error is reported. This check is necessarily approximate because dependencies
under function expressions are assumed to be delayed, and in this case the use of a lazy initialization
means that runtime checks and forces are inserted.</p>
<blockquote>
<p>Note: In F# 3 .1 this check does not apply to value definitions that are generic through
generalization because a generic value definition is not executed immediately, but is
instead represented as a generic method. For example, the following value definitions
are generic because each right-hand-side is generalizable:</p>
</blockquote>
<pre><code class="language-fsharp">let rec a = b
and b = a
</code></pre>
<blockquote>
<p>In compiled code they are represented as a pair of generic methods, as if the code had
been written as follows:</p>
</blockquote>
<pre><code class="language-fsharp">let rec a&lt;'T&gt;() = b&lt;'T&gt;()
and b&lt;'T&gt;() = a&lt;'T&gt;()
</code></pre>
<blockquote>
<p>As a result, the definitions are not executed immediately unless the functions are called.
Such definitions indicate a programmer error, because executing such generic,
immediately recursive definitions results in an infinite loop or an exception. In practice
these definitions only occur in pathological examples, because value definitions are
generalizable only when the right-hand-side is very simple, such as a single value. Where
this issue is a concern, type annotations can be added to existing value definitions to
ensure they are not generic. For example:</p>
</blockquote>
<pre><code class="language-fsharp">let rec a : int = b
and b : int = a
</code></pre>
<blockquote>
<p>In this case, the definitions are not generic. The compiler performs immediate
dependency analysis and reports an error. In addition, record fields in recursive data
expressions must be initialized in the order they are declared. For example:</p>
</blockquote>
<pre><code class="language-fsharp">type Foo = {
    x: int
    y: int
    parent: Foo option
    children: Foo list
}

let rec parent = { x = 0; y = 0; parent = None; children = children }
and children = [{ x = 1; y = 1; parent = Some parent; children = [] }]

printf &quot;%A&quot; parent
</code></pre>
<blockquote>
<p>Here, if the order of the fields x and y is swapped, a type-checking error occurs.</p>
</blockquote>
<h3 id="generalization">Generalization</h3>
<p>Generalization is the process of inferring a generic type for a definition where possible, thereby
making the construct reusable with multiple different types. Generalization is applied by default at
all function, value, and member definitions, except where listed later in this section. Generalization
also applies to member definitions that implement generic virtual methods in object expressions.</p>
<p>Generalization is applied incrementally to items in a recursive group after each item is checked.</p>
<p>Generalization takes a set of ungeneralized but type-checked definitions <em>checked-defns</em> that form
part of a recursive group, plus a set of unchecked definitions <em>unchecked-defns</em> that have not yet been
checked in the recursive group, and an environment <em>env</em>. Generalization involves the following steps:</p>
<ol>
<li>
<p>Choose a subset <code>generalizable-defns</code> of <code>checked-defns</code> to generalize.</p>
<p>A definition can be generalized if its inferred type is closed with respect to any inference
variables that are present in the types of the <code>unchecked-defns</code> that are in the recursive group and
that are not yet checked or which, in turn, cannot be generalized. A greatest-fixed-point
computation repeatedly removes definitions from the set of <code>checked-defns</code> until a stable set of
generalizable definitions remains.
2. Generalize all type inference variables that are not otherwise ungeneralizable and for which any
of the following is true:
- The variable is present in the inferred types of one or more of <code>generalizable-defns</code>.
- The variable is a type parameter copied from the enclosing type definition (for members and
   “let” definitions in classes).
- The variable is explicitly declared as a generic parameter on an item.</p>
</li>
</ol>
<p>The following type inference variables cannot be generalized:</p>
<ul>
<li>A type inference variable <code>^typar</code> that is part of the inferred or declared type of a definition,
    unless the definition is marked <code>inline</code>.</li>
<li>A type inference variable in an inferred type in the <em>ExprItems</em> or <em>PatItems</em> tables of <code>env</code> , or in
    an inferred type of a module in the <em>ModulesAndNamespaces</em> table in <code>env</code>.</li>
<li>A type inference variable that is part of the inferred or declared type of a definition in which
    the elaborated right-hand side of the definition is not a generalizable expression, as
    described later in this section.</li>
<li>A type inference variable that appears in a constraint that itself refers to an ungeneralizable
    type variable.</li>
</ul>
<p>Generalizable type variables are computed by a greatest-fixed-point computation, as follows:</p>
<ol>
<li>
<p>Start with all variables that are candidates for generalization.</p>
</li>
<li>
<p>Determine a set of variables <code>U</code> that cannot be generalized because they are free in the
environment or present in ungeneralizable definitions.</p>
</li>
<li>
<p>Remove the variables in <em>U</em> from consideration.</p>
</li>
<li>
<p>Add to <code>U</code> any inference variables that have a constraint that involves a variable in <code>U</code>.</p>
</li>
<li>
<p>Repeat steps 2 through 4.</p>
</li>
</ol>
<p>Informally, generalizable expressions represent a subset of expressions that can be freely copied and
instantiated at multiple types without affecting the typical semantics of an F# program. The
following expressions are generalizable:</p>
<ul>
<li>A function expression</li>
<li>An object expression that implements an interface</li>
<li>A delegate expression</li>
<li>A “let” definition expression in which both the right-hand side of the definition and the body of
    the expression are generalizable</li>
<li>A “let rec” definition expression in which the right-hand sides of all the definitions and the body
    of the expression are generalizable</li>
<li>A tuple expression, all of whose elements are generalizable</li>
<li>A record expression, all of whose elements are generalizable, where the record contains no
    mutable fields</li>
<li>A union case expression, all of whose arguments are generalizable</li>
<li>An exception expression, all of whose arguments are generalizable</li>
<li>An empty array expression</li>
<li>A simple constant expression</li>
<li>An application of a type function that has the <code>GeneralizableValue</code> attribute.</li>
</ul>
<p>Explicit type parameter definitions on value and member definitions can affect the process of type
inference and generalization. In particular, a declaration that includes explicit generic parameters
will not be generalized beyond those generic parameters. For example, consider this function:</p>
<pre><code class="language-fsharp">let f&lt;'T&gt; (x : 'T) y = x
</code></pre>
<p>During type inference, this will result in a function of the following type, where <code>'_b</code> is a type
inference variable that is yet to be resolved.</p>
<pre><code class="language-fsharp">f&lt;'T&gt; : 'T -&gt; '_b -&gt; '_b
</code></pre>
<p>To permit generalization at these definitions, either remove the explicit generic parameters (if they
can be inferred), or use the required number of parameters, as the following example shows:</p>
<pre><code class="language-fsharp">let throw&lt;'T,'U&gt; (x:'T) (y:'U) = x
</code></pre>
<h3 id="condensation-of-generalized-types">Condensation of Generalized Types</h3>
<p>After a function or member definition is generalized, its type is condensed by removing generic type
parameters that apply subtype constraints to argument positions. (The removed flexibility is
implicitly reintroduced at each use of the defined function; see <a href="./#implicit-insertion-of-flexibility-for-uses-of-functions-and-members">§14.4.3</a>).</p>
<p>Condensation decomposes the type of a value or member to the following form:</p>
<pre><code class="language-fsgrammar">ty11 * ... * ty1n -&gt; ... -&gt; tym1 * ... * tymn -&gt; rty
</code></pre>
<p>The positions <code>tyij</code> are called the parameter positions for the type.</p>
<p>Condensation applies to a type parameter <code>'a</code> if all of the following are true:</p>
<ul>
<li><code>'a</code> is not an explicit type parameter.</li>
<li><code>'a</code> occurs at exactly one <code>tyij</code> parameter position.</li>
<li><code>'a</code> has a single coercion constraint <code>'a :&gt; ty</code> and no other constraints. However, one additional
    nullness constraint is permitted if <code>ty</code> satisfies the nullness constraint.</li>
<li><code>'a</code> does not occur in any other <code>tyij</code>, nor in <code>rty</code>.</li>
<li><code>'a</code> does not occur in the constraints of any condensed <code>typar</code>.</li>
</ul>
<p>Condensation is a greatest-fixed-point computation that initially assumes all generalized type
parameters are condensed, and then progressively removes type parameters until a minimal set
remains that satisfies the above rules.</p>
<p>The compiler removes all condensed type parameters and replaces them with their subtype
constraint <code>ty</code>. For example:</p>
<pre><code class="language-fsharp">let F x = (x :&gt; System.IComparable).CompareTo(x)
</code></pre>
<p>After generalization, the function is inferred to have the following type:</p>
<pre><code class="language-fsharp">F : 'a -&gt; int when 'a :&gt; System.IComparable
</code></pre>
<p>In this case, the actual inferred, generalized type for <code>F</code> is condensed to:</p>
<pre><code class="language-fsharp">F : System.IComparable -&gt; R
</code></pre>
<p>Condensation does not apply to arguments of unconstrained variable type. For example:</p>
<pre><code class="language-fsharp">let ignore x = ()
</code></pre>
<p>with type</p>
<pre><code class="language-fsharp">ignore: 'a -&gt; unit
</code></pre>
<p>In particular, this is not condensed to</p>
<pre><code class="language-fsharp">ignore: obj -&gt; unit
</code></pre>
<p>In rare cases, condensation affects the points at which value types are boxed. In the following
example, the value <code>3</code> is now boxed at uses of the function:</p>
<pre><code class="language-fsharp">F 3
</code></pre>
<p>If a function is not generalized, condensation is not applied. For example, consider the following:</p>
<pre><code class="language-fsharp">let test1 =
    let ff = Seq.map id &gt;&gt; Seq.length
    (ff [1], ff [| 1 |]) // error here
</code></pre>
<p>In this example, <code>ff</code> is not generalized, because it is not defined by using a generalizable expression—
computed functions such as <code>Seq.map id &gt;&gt; Seq.length</code> are not generalizable. This means that its
inferred type, after processing the definition, is</p>
<pre><code class="language-fsharp">F : '_a -&gt; int when '_a :&gt; seq&lt;'_b&gt;
</code></pre>
<p>where the type variables are not generalized and are unsolved inference variables. The application
of <code>ff</code> to <code>[1]</code> equates <code>'a</code> with <code>int list</code>, making the following the type of <code>F</code>:</p>
<pre><code class="language-fsharp">F : int list -&gt; int
</code></pre>
<p>The application of <code>ff</code> to an array type then causes an error. This is similar to the error returned by
the following:</p>
<pre><code class="language-fsharp">let test1 =
    let ff = Seq.map id &gt;&gt; Seq.length
    (ff [1], ff [&quot;one&quot;]) // error here
</code></pre>
<p>Again, <code>ff</code> is not generalized, and its use with arguments of type <code>int list</code> and <code>string list</code> is not
permitted.</p>
<h2 id="dispatch-slot-inference">Dispatch Slot Inference</h2>
<p>The F# compiler applies <em>Dispatch Slot Inference</em> to object expressions and type definitions before it
processes their members. For both object expressions and type definitions, the following are input
to <em>Dispatch Slot Inference</em>:</p>
<ul>
<li>A type <code>ty0</code> that is being implemented.</li>
<li>A set of members <code>override x.M(arg1 ... argN)</code>.</li>
<li>A set of additional interface types <code>ty1 ... tyn</code>.</li>
<li>A further set of members <code>override x.M(arg1 ... argN)</code> for each <code>tyi</code>.</li>
</ul>
<p>Dispatch slot inference associates each member with a unique abstract member or interface
member that the collected types <code>tyi</code> define or inherit.</p>
<p>The types <code>ty0 ... tyn</code> together imply a collection of <em>required types</em> R, each of which has a set of
<em>required dispatch slots</em> SlotsR of the form <code>abstract M : aty1 ... atyN -&gt; atyrty</code>. Each dispatch slot is
placed under the <em>most-specific</em> <code>tyi</code> relevant to that dispatch slot. If there is no most-specific type for
a dispatch slot, an error occurs.</p>
<p>For example, assume the following definitions:</p>
<pre><code class="language-fsharp">type IA = interface abstract P : int end
type IB = interface inherit IA end
type ID = interface inherit IB end
</code></pre>
<p>With these definitions, the following object expression is legal. Type <code>IB</code> is the most-specific
implemented type that encompasses <code>IA</code>, and therefore the implementation mapping for <code>P</code> must be
listed under <code>IB</code>:</p>
<pre><code class="language-fsharp">let x = { new ID
          interface IB with
            member x.P = 2 }
</code></pre>
<p>But given:</p>
<pre><code class="language-fsharp">type IA = interface abstract P : int end
type IB = interface inherit IA end
type IC = interface inherit IB end
type ID = interface inherit IB inherit IC end
</code></pre>
<p>then the following object expression causes an error, because both <code>IB</code> and <code>IC</code> include the interface
<code>IA</code>, and consequently the implementation mapping for <code>P</code> is ambiguous.</p>
<pre><code class="language-fsharp">let x = { new ID
          interface IB with
            member x.P = 2
          interface IC with
            member x.P = 2 }
</code></pre>
<p>The ambiguity can be resolved by explicitly implementing interface <code>IA</code>.</p>
<p>After dispatch slots are assigned to types, the compiler tries to associate each member with a
dispatch slot based on name and number of arguments. This is called <em>dispatch slot inference,</em> and it
proceeds as follows:</p>
<ul>
<li>
<p>For each <code>member x.M(arg1 ... argN)</code> in type <code>tyi</code>, attempt to find a single dispatch slot in the form</p>
<p><code>fsgrammar
abstract M : aty1 ... atyN -&gt; rty</code>
with name <code>M</code>, argument count <code>N</code>, and most-specific implementing type <code>tyi</code>.</p>
</li>
<li>
<p>To determine the argument counts, analyze the syntax of patterns and look specifically for
    tuple and unit patterns. Thus, the following members have argument count 1, even though
    the argument type is unit:
    <code>fsgrammar
    member obj.ToString(() | ()) = ...
    member obj.ToString(():unit) = ...
    member obj.ToString(_:unit) = ...</code></p>
</li>
<li>A member may have a return type, which is ignored when determining argument counts:
    <code>fsother
    member obj.ToString() : string = ...</code></li>
</ul>
<p>For example, given</p>
<pre><code class="language-fsharp">let obj1 =
    { new System.Collections.Generic.IComparer&lt;int&gt; with
        member x.Compare(a,b) = compare (a % 7) (b % 7) }
</code></pre>
<p>the types of <code>a</code> and <code>b</code> are inferred by looking at the signature of the implemented dispatch slot, and
are hence both inferred to be <code>int</code>.</p>
<h2 id="dispatch-slot-checking">Dispatch Slot Checking</h2>
<p><em>Dispatch Slot Checking</em> is applied to object expressions and type definitions to check consistency
properties, such as ensuring that all abstract members are implemented.</p>
<p>After the compiler checks all bodies of all methods, it checks that a one-to-one mapping exists
between dispatch slots and implementing members based on exact signature matching.</p>
<p>The interface methods and abstract method slots of a type are collectively known as <em>dispatch slots</em>.
Each object expression and type definition results in an elaborated <em>dispatch map</em>. This map is keyed
by dispatch slots, which are qualified by the declaring type of the slot. This means that a type that
supports two interfaces <code>I</code> and <code>I2</code>, both of which contain the method m, may supply different
implementations for <code>I.m()</code> and <code>I2.m()</code>.</p>
<p>The construction of the dispatch map for any particular type is as follows:</p>
<ul>
<li>If the type definition or extension has an implementation of an interface, mappings are added
    for each member of the interface,</li>
<li>If the type definition or extension has a <code>default</code> or <code>override</code> member, a mapping is added for the
    associated abstract member slot.</li>
</ul>
<h2 id="byref-safety-analysis">Byref Safety Analysis</h2>
<p>Byref arguments are pointers that can be stack-bound and are used to pass values by reference to
procedures in CLI languages, often to simulate multiple return values. Byref pointers are not often
used in F#; more typically, tuple values are used for multiple return values. However, a byref value
can result from calling or overriding a CLI method that has a signature that involves one or more
byref values.</p>
<p>To ensure the safety of byref arguments, the following checks are made:</p>
<ul>
<li>Byref types may not be used as generic arguments.</li>
<li>Byref values may not be used in any of the following:<ul>
<li>The argument types or body of function expressions <code>(fun ... -&gt; ...)</code>.</li>
<li>The member implementations of object expressions.</li>
<li>The signature or body of let-bound functions in classes.</li>
<li>The signature or body of let-bound functions in expressions.</li>
</ul>
</li>
</ul>
<p>Note that function expressions occur in:</p>
<ul>
<li>The elaborated form of sequence expressions.</li>
<li>The elaborated form of computation expressions.</li>
<li>The elaborated form of partial applications of module-bound functions and members.</li>
</ul>
<p>In addition:</p>
<ul>
<li>A generic type cannot be instantiated by a byref type.</li>
<li>An object field cannot have a byref type.</li>
<li>A static field or module-bound value cannot have a byref type.</li>
</ul>
<p>As a result, a byref-typed expression can occur only in these situations:</p>
<ul>
<li>
<p>As an argument to a call to a module-defined function or class-defined function.</p>
</li>
<li>
<p>On the right-hand-side of a value definition for a byref-typed local.</p>
</li>
</ul>
<p>These restrictions also apply to uses of the prefix &amp;&amp; operator for generating native pointer values.</p>
<h2 id="promotion-of-escaping-mutable-locals-to-objects">Promotion of Escaping Mutable Locals to Objects</h2>
<p>Value definitions whose byref address would be subject to the restrictions on <code>byref&lt;_&gt;</code> listed in
<a href="./#byref-safety-analysis">§14.9</a> are treated as implicit declarations of reference cells. For example</p>
<pre><code class="language-fsharp">let sumSquares n =
    let mutable total = 0
    [ 1 .. n ] |&gt; Seq.iter (fun x -&gt; total &lt;- total + x*x)
    total
</code></pre>
<p>is considered equivalent to the following definition:</p>
<pre><code class="language-fsharp">let sumSquares n =
    let total = ref 0
    [ 1 .. n ] |&gt; Seq.iter
                    (fun x -&gt; total.contents &lt;- total.contents + x*x)
    total.contents
</code></pre>
<p>because the following would be subject to byref safety analysis:</p>
<pre><code class="language-fsharp">let sumSquares n =
    let mutable total = 0
    &amp;total
</code></pre>
<h2 id="arity-inference">Arity Inference</h2>
<p>During checking, members within types and function definitions within modules are inferred to have
an <em>arity</em>. An arity includes both of the following:</p>
<ul>
<li>The number of iterated (curried) arguments <code>n</code></li>
<li>A tuple length for these arguments <code>[A1; ...; An]</code>. A tuple length of zero indicates that the
    corresponding argument is of type <code>unit</code>.</li>
</ul>
<p>Arities are inferred as follows. A function definition of the following form is given arity <code>[A1; ...; An]</code>,
where each <code>Ai</code> is derived from the tuple length for the final inferred types of the patterns:</p>
<pre><code class="language-fsother">let ident pat 1 ... patn = ...
</code></pre>
<p>For example, the following is given arity [1; 2]:</p>
<pre><code class="language-fsharp">let f x (y,z) = x + y + z
</code></pre>
<p>Arities are also inferred from function expressions that appear on the immediate right of a value
definition. For example, the following has an arity of [1]:</p>
<pre><code class="language-fsharp">let f = fun x -&gt; x + 1
</code></pre>
<p>Similarly, the following has an arity of [1;1]:</p>
<pre><code class="language-fsharp">let f x = fun y -&gt; x + y
</code></pre>
<p>Arity inference is applied partly to help define the elaborated form of a function definition. This is
the form that other CLI languages see. In particular:</p>
<ul>
<li>A function value <code>F</code> in a module that has arity <code>[A1 ; ...; An]</code> and the type
    <code>ty1,1 * ... * ty1,A1 -&gt; ... -&gt; tyn,1 * ... * tyn,An - &gt; rty</code>
    elaborates to a CLI static method definition with signature
    <code>rty F(ty1,1, ..., ty1,A1, ..., tyn,1 , ..., tyn,An)</code>.</li>
<li>F# instance (respectively static) methods that have arity <code>[A1 ; ...; An]</code> and type
    <code>ty1,1 * ... * ty1,A1 -&gt; ... -&gt; tyn,1 * ... * tynAn -&gt; rty</code>
    elaborate to a CLI instance (respectively static) method definition with signature
    <code>rty F(ty1,1, ..., ty1,A1)</code>, subject to the syntactic restrictions that result from the patterns that
    define the member, as described later in this section.</li>
</ul>
<p>For example, consider a function in a module with the following definition:</p>
<pre><code class="language-fsharp">let AddThemUp x (y, z) = x + y + z
</code></pre>
<p>This function compiles to a CLI static method with the following C# signature:</p>
<pre><code class="language-fsharp">int AddThemUp(int x, int y, int z);
</code></pre>
<p>Arity inference applies differently to function and member definitions. Arity inference on function
definitions is fully type-directed. Arity inference on members is limited if parentheses or other
patterns are used to specify the member arguments. For example:</p>
<pre><code class="language-fsharp">module Foo =
    // compiles as a static method taking 3 arguments
    let test1 (a1: int, a2: float, a3: string) = ()

    // compiles as a static method taking 3 arguments
    let test2 (aTuple : int * float * string) = ()

    // compiles as a static method taking 3 arguments
    let test3 ( (aTuple : int * float * string) ) = ()

    // compiles as a static method taking 3 arguments
    let test4 ( (a1: int, a2: float, a3: string) ) = ()

    // compiles as a static method taking 3 arguments
    let test5 (a1, a2, a3 : int * float * string) = ()

type Bar() =
    // compiles as a static method taking 3 arguments
    static member Test1 (a1: int, a2: float, a3: string) = ()

    // compiles as a static method taking 1 tupled argument
    static member Test2 (aTuple : int * float * string) = ()

    // compiles as a static method taking 1 tupled argument
    static member Test3 ( (aTuple : int * float * string) ) = ()

    // compiles as a static method taking 1 tupled argument
    static member Test4 ( (a1: int, a2: float, a3: string) ) = ()

    // compiles as a static method taking 1 tupled argument
    static member Test5 (a1, a2, a3 : int * float * string) = ()
</code></pre>
<h2 id="additional-constraints-on-cli-methods">Additional Constraints on CLI Methods</h2>
<p>F# treats some CLI methods and types specially, because they are common in F# programming and
cause extremely difficult-to-find bugs. For each use of the following constructs, the F# compiler
imposes additional <em>ad hoc</em> constraints:</p>
<p><code>x.Equals(yobj)</code> requires type <code>ty : equality</code> for the static type of <code>x</code></p>
<p><code>x.GetHashCode()</code> requires type <code>ty : equality</code> for the static type of <code>x</code></p>
<p><code>new Dictionary&lt;A,B&gt;()</code> requires <code>A : equality</code>, for any overload that does not take an
<code>IEqualityComparer&lt;T&gt;</code></p>
<p>No constraints are added for the following operations. Consider writing wrappers around these
functions to improve the type safety of the operations.</p>
<p><code>System.Array.BinarySearch&lt;T&gt;(array,value)</code> requiring <code>C : comparison</code>, for any overload that
does not take an <code>IComparer&lt;T&gt;</code></p>
<p><code>System.Array.IndexOf</code> requiring <code>C : equality</code></p>
<p><code>System.Array.LastIndexOf(array,T)</code> requiring <code>C : equality</code></p>
<p><code>System.Array.Sort&lt;'T&gt;(array)</code> requiring <code>C : comparison</code>, for any overload that does not take an
<code>IEqualityComparer&lt;T&gt;</code></p>
<p><code>new SortedList&lt;A,B&gt;()</code> requiring <code>A : comparison</code>, for any overload that does not take an
<code>IEqualityComparer&lt;T&gt;</code></p>
<p><code>new SortedDictionary&lt;A,B&gt;()</code> requiring <code>C : comparison</code>, for any overload that does not take an
<code>IEqualityComparer&lt;_&gt;</code></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2005-2025 F# contributors. Made available under the <a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons CC-by 4.0</a> licence.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>